<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Homocysteine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Homocysteine">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Homocysteine">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Homocysteine">
  
    <link rel="alternate" href="/atom.xml" title="Homocysteine" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Homocysteine</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-abstract-class-and-interface" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/25/abstract-class-and-interface/" class="article-date">
  <time datetime="2020-06-25T07:00:35.000Z" itemprop="datePublished">2020-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/25/abstract-class-and-interface/">abstract class and interface</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#抽象方法<br>使用abstract关键字修饰，只有声明，没有具体实现；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract void run();</span><br></pre></td></tr></table></figure></p>
<p>抽象方法必须为public或者protected</p>
<p>#抽象类</p>
<ol>
<li>一个类含有抽象方法，则为抽象类，需要用abstarct修饰class</li>
<li>抽象类不能创建对象</li>
<li>一个类继承了抽象类，则必须实现抽象方法，否则这个子类也将变成抽象类</li>
</ol>
<p>#接口<br>在软件工程中，接口泛指提供给别人调用的方法或函数</p>
<ol>
<li>Java接口中的变量默认为public static final变量</li>
<li>方法默认是public abstract</li>
<li>非抽象类实现某个接口，【就必须实现该接口中的所有方法】</li>
</ol>
<p>抽象类是对事物的抽象，接口是对行为的抽象<br>飞机、鸟、飞</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/25/abstract-class-and-interface/" data-id="ckc4v5z2b000m7wwz9nhwbbkm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-singleton" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/25/singleton/" class="article-date">
  <time datetime="2020-06-25T03:45:03.000Z" itemprop="datePublished">2020-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/25/singleton/">singleton</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#要点</p>
<ol>
<li>某个类只能有一个实例<br>实现：构造函数私有化</li>
<li>类必须自行创建实例<br>实现：含有一个类的静态变量来保存这个唯一实例</li>
</ol>
<p>最简单的一种方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    public static final singleton = new Singleton();</span><br><span class="line">    private <span class="function"><span class="title">Singleton</span></span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/25/singleton/" data-id="ckc4v5z2p000v7wwzc4hp2f4l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Internal-class" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/25/Internal-class/" class="article-date">
  <time datetime="2020-06-25T02:11:12.000Z" itemprop="datePublished">2020-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/25/Internal-class/">Internal-class</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#成员内部类</p>
<ol>
<li>直接定义在另一个类中的类</li>
<li>内部类可以使用外部类的所有成员</li>
<li><p>当内部类成员和外部类成员同名时，内部类默认使用的是内部成员。如果要使用外部成员</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.this.成员</span><br></pre></td></tr></table></figure>
</li>
<li><p>外部类如果想访问内部成员，需要创建一个内部类对象，再通过这个对象引用内部类的成员</p>
</li>
<li><p>内部类对象是依附于外部类对象存在的，创建内部类对象的方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outter otter = new Outter();</span><br><span class="line">Outter.Inner inner = outter.new Inner();</span><br></pre></td></tr></table></figure>
</li>
<li><p>外部类访问权限：<br>public(可以被本项目的其它类使用，类名必须要和文件名相同)；<br>default（只能被同一个包中的类访问）</p>
</li>
<li><p>内部类访问权限：<br>public:任何地方都可以被访问；<br>protected:同一个包下或者外部类的子类可以访问<br>default:同一个包下的类可以访问<br>private：只能在所在外部类中被访问</p>
</li>
</ol>
<p>#局部内部类<br>定义在一个方法或者作用域中的类，访问仅限于方法内或者作用域内<br>不能有修饰符，像一个局部变量一样</p>
<p>#匿名内部类<br>经典：Android设置按钮监听器<br>创建匿名内部类时能够实现父类或者接口中的方法<br>匿名内部类也无法修饰<br>匿名内部类没有构造器，编译器自动起名</p>
<p>#静态内部类<br>不依赖于外部类，类似于静态成员<br>不能使用外部类的非静态成员<br>创建静态内部类对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outter.Inner inner = new Outter.Inner();</span><br></pre></td></tr></table></figure></p>
<p>内部类会被单独编译成一个字节码文件outter$inner.class<br>内部类方便了类的组合<br>内部类使用外部控件，加final修饰，目的是为了防止button被修改</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/25/Internal-class/" data-id="ckc4v5z1p00087wwzfju9pxq8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-memory-model" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/24/java-memory-model/" class="article-date">
  <time datetime="2020-06-24T14:18:20.000Z" itemprop="datePublished">2020-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/24/java-memory-model/">java-memory-model</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#JVM三大性能调优参数-Xms -Xmx -Xss的含义<br><img src="/2020/06/24/java-memory-model/three-parameter.png" alt=""><br>-Xss规定了每个线程虚拟机栈的大小（stack）<br>-Xms规定了堆的初始容量<br>-Xmx规定了堆的最大容量（一般和-Xms设置成一样的，防止内存抖动）</p>
<p>#内存分配的三种策略：</p>
<ol>
<li>静态存储：在编译时确定每个数据目标运行时的内存需求（不能有可变数据结构、嵌套、递归）</li>
<li>栈式存储：编译时未知，运行时模块入口前确定</li>
<li>对是存储：编译时未知，运行时模块入口时也未知，动态分配内存</li>
</ol>
<p>#Java内存模型中堆和栈的区别<br>数组、对象实例都保存在堆中，在栈中定义变量保存堆中实例的首地址（引用变量）</p>
<ol>
<li>所以，引用变量会自动释放，而实例本身不会，实例对象本身存储在堆中，等待GC处理</li>
<li>所以当我们用String str = new String(“123”)创建对象时，会在栈中创建一个引用对象（地址），在对中创建一个实例对象。<br>new出来的在堆里</li>
<li>区别一：栈自动释放，堆GC管理</li>
<li>区别二：栈一般比堆要小</li>
<li>区别三：堆活动量较大，GC的非实时性，产生的碎片量较多</li>
<li>区别四：栈支持静态和动态，对仅支持动态（是堆的优点，更灵活）</li>
<li>区别五：栈的效率要比堆要搞</li>
</ol>
<p>#equals VS ==</p>
<ol>
<li>equals比较的是两个对象实例在内存中的内容</li>
<li>==比较的则是两个引用变量的值，即实例变量在堆中的首地址</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/24/java-memory-model/" data-id="ckc4v5z2g000p7wwzru0s4gza" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/23/设计模式/" class="article-date">
  <time datetime="2020-06-23T02:32:22.000Z" itemprop="datePublished">2020-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/23/设计模式/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#MVP模式<br>M-&gt;Model;V-&gt;View;P-&gt;Presenter<br>MVP从经典的MVC演变而来，与MVC类似Controller/Presenter负责逻辑的处理，Model负责提供数据，View负责显示<br>M数据处理（网络操作、数据库操作），V视图层显示，C交互处理<br>MVC中view会直接从Model中读取数据，而不是Controller<br>MVP中View不会直接使用Model，它们之间的通信是使用Presenter进行的</p>
<p>MVC优点：</p>
<ol>
<li>低耦合：降低了M和V的关联程度</li>
<li>将业务逻辑和界面分离，增强了程序的可维护性和可扩展性。比如待修改界面时，只需要更改V层；当需要新的数据需求时，只需要增加新的接口。</li>
<li>职责划分比较明确<br>MVC缺点：</li>
<li>MVC适用于逻辑处理复杂、需要模块化设计的大项目；小项目中使用MVC可能会导致程序过度设计，代码臃肿。</li>
<li>Activity中有很多关于视图UI的代码，所以在Activity中并不是单纯的C，还包括V的部分</li>
<li>View和Model还是互相耦合</li>
</ol>
<p>MVP模式是MVC模式在Android上的一种变体<br>MVC中Activity还是承担了M和C这两个层的工作，耦合度还是有点高，所以将Activity中的view和controller抽离出来，变成View和Presenter，这就是MVP模式</p>
<p>MVC模式中Activity的耦合度还是太高，业务逻辑与显示逻辑都写在Activity中，容易增城Activity臃肿。<br>而且写在Activity中的代码意味着不能被复用了</p>
<p>在MVP架构中，</p>
<ol>
<li>Model还是那个Model，Activity的UI逻辑层被抽象成View接口，业务逻辑层被抽象成Presenter接口。</li>
<li>Model和View之间也不能直接的进行交互</li>
<li>使代码更加简洁，进一步降低耦合，可以进行逻辑代码的复用</li>
<li>具体实现，在Activity中主要编写UI逻辑，业务逻辑写在一个接口中，然后去实现这个接口</li>
</ol>
<p>##MVVM模式<br>MVVM将MVC的Controller改进成ViewModel<br>在MVVM框架下，View和Model是不能直接通信的<br>ViewModel能够监听两端的变化，“实现数据的双向绑定”</p>
<p>重制</p>
<p>#不用框架<br>所以逻辑代码都写在一个Activity中，Activity承担过多的任务<br>当项目代码增加时，activity将会变得愈发的臃肿，难以维护</p>
<p>使用架构的目的是为了优化代码，提高开发和维护效率</p>
<p>#MVC<br>对代码进行解耦，将数据的获取、页面的展示分隔开来<br>M-&gt;V-&gt;C-&gt;M 形成一个三角循环<br>Controller:Activity、Fragment 处理外部请求、处理业务逻辑<br>View：layout、View控件<br>Model：数据库、网络数据获取</p>
<p>controller-&gt;Model 通过引用，Controller可以创建Model层的引用，来进行两层之间的通信<br>model-&gt;View 注册监听</p>
<p>优点：一定程度上实现实现了Model和View的分离，增强了可维护性，降低耦合性<br>缺点：</p>
<ol>
<li>适合大项目，小项目容易过度开发</li>
<li>Model和View并没有完全的实现隔离</li>
<li>Controller与View没有完全解耦，随着业务量增加，Controller将会变得更加臃肿（Controlller通常指Activity，Activity兼顾了视图和业务量部分的工作）</li>
</ol>
<p>#MVP<br>Model<-->Presenter<-->View</--></--></p>
<ol>
<li>Model与View不再进行直接的通信，Presenter是两层通信的桥梁</li>
<li>Activity充当view，主要负责视图层逻辑</li>
<li>业务逻辑处理交给Presenter，Presenter持有Model和View的引用来进行通信</li>
<li>通过重写接口函数来展示页面，方便每个Activity进行编写</li>
<li>View通过Presenter的引用和Presenter进行通信<br>e.g. View层通过Presenter的引用调用Presenter的获取数据的方法，Presenter在方法中通过model的引用获取数据，在通过view的引用更新页面</li>
</ol>
<p>优点：</p>
<ol>
<li>使Model和View完全隔离</li>
<li>解决了MVC中View和Controller过度耦合的缺点</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要编写很多的接口</li>
<li>随着项目复杂度提高，Presenter将变得臃肿</li>
</ol>
<p>#MVVM</p>
<ol>
<li>通信图相同，只不过将Presenter改成了ViewModel</li>
<li>在MVP的基础上，实现了数据的绑定（当数据发生变化时，视图自动更新；当视图发生变化时，数据也自动更新）</li>
<li>减少了接口数量、控件引用数量</li>
</ol>
<p>#数据绑定<br>DataBinding是谷歌官方发布的一个数据绑定框架，实现数据与视图的数据绑定</p>
<p>优点：实现双向绑定，极大简化了代码。减少了接口、引用数量。<br>缺点：数据绑定还不成熟</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/23/设计模式/" data-id="ckc4v5z2v00127wwzilumi519" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-foundamental" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/19/java-foundamental/" class="article-date">
  <time datetime="2020-06-19T03:46:03.000Z" itemprop="datePublished">2020-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/19/java-foundamental/">java foundamental</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java参数传递"><a href="#Java参数传递" class="headerlink" title="Java参数传递"></a>Java参数传递</h1><ol>
<li>基础数据类型是值传递</li>
<li>对象类型，实参和形参指向同一片内存，但是如果更改形参指向，不会影响实参</li>
<li>指针和引用还是有区别的，指针无法改变指向</li>
</ol>
<h1 id="Java继承"><a href="#Java继承" class="headerlink" title="Java继承"></a>Java继承</h1><ol>
<li>子类可以继承父类的 所有 属性和方法，还可以重写父类的方法，但是私有的是不能调用的</li>
<li>Object类是层次结构的根，java所有类都继承自这个类</li>
<li>构造子类对象前，要先构造父类对象，用super关键字实现</li>
<li>子类带参要先调父类带参</li>
<li>子类咔嚓一下就可以转换成父类，这是安全的，转换成谁，谁在左边</li>
<li>父类转换成子类时，需要用（）来实现强制转换</li>
<li>接口只有静态常量和抽象方法，十分抽象的类</li>
<li>定义接口是帮助子类进行扩展</li>
<li>Java只允许单继承，降低复杂性，但是可以实现多个接口；C++允许多继承</li>
</ol>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ol>
<li>static修饰类，只能修饰内部类</li>
<li>static修饰的方法可以通过类名来直接调用</li>
<li>static修饰的变量属于类，可以通过类名直接调用</li>
<li>类初始化顺序：先父类，后子类；先静态和非静态</li>
<li>父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数</li>
<li>java的对象放在堆区，线程共享；其它放在栈区，每个线程有一个</li>
<li>类和静态区存放在静态区，线程共享</li>
<li>静态随类，非静态随对象，所以静态方法中无法使用this、super</li>
<li>静态变量被所有类实例共享</li>
</ol>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><ol>
<li>final修饰类，则这个类不能被继承</li>
<li>final修饰方法，则这个方法不能被重写</li>
<li>final修饰基础类型变量，必须初始化，且只能初始化一次</li>
<li>final修饰对象类型变量，地址不能变</li>
</ol>
<h1 id="java编程知识积累"><a href="#java编程知识积累" class="headerlink" title="java编程知识积累"></a>java编程知识积累</h1><ol>
<li>java数组为null和空数组是不一样的概念。null表示这个对象引用是一个空引用；空数组表示是一个真正的对象，只不过元素数量为0</li>
</ol>
<h1 id="java异常"><a href="#java异常" class="headerlink" title="java异常"></a>java异常</h1><h2 id="java异常体系主要回答的三个问题"><a href="#java异常体系主要回答的三个问题" class="headerlink" title="java异常体系主要回答的三个问题"></a>java异常体系主要回答的三个问题</h2><p>what:异常类型回答了什么被抛出<br>where:异常堆栈跟踪回答了在哪里被抛出<br>why:异常信息回答了为什么会被抛出</p>
<h2 id="java的异常体系"><a href="#java的异常体系" class="headerlink" title="java的异常体系"></a>java的异常体系</h2><p><img src="/2020/06/19/java-foundamental/java_Exception.png" alt=""></p>
<ol>
<li>java异常的顶层父类是Throwable类，Throwable继承自Object类</li>
<li>Error:(JVM负责)程序无法处理的系统错误，编译器不做检查，遇到建议直接让程序终止 e.g. 系统崩溃、虚拟机错误、内存不足、方法调用栈溢出</li>
<li>Exception:程序可以处理的异常，捕获后可能修复，遇到应该尽可能去处理</li>
<li>Exception又可以分为runtimeException和非runtimeException</li>
<li>RuntimeException（程序负责）表示不可预知的，编译器不校验，程序应当进行避免 e.g.数组下标越界（outofIndex）、访问控制针(NullPointerException)</li>
<li>非runtimeException，（编译器负责）可以预知的错误，编译器校验的异常，不处理，程序不能被编译通过 I/OException、SQLException、ClassNotFound、EOFException<br>ps:java不能一个继承多个，但是可以一个被多个继承</li>
<li>尽量细化异常，不要泛化异常，因为一场本身就是为了方便定位问题的<h2 id="java常见Error和异常"><a href="#java常见Error和异常" class="headerlink" title="java常见Error和异常"></a>java常见Error和异常</h2></li>
<li>runtimeException<br>NullPointerException:在试图使用的对象是null<br>ClassCastException:不兼容类型之间的转换异常<br>IllegalArgumentException:传递非法参数的异常<br>IndexOutOfBoundsException:下标越界异常<br>NumberFormatException:将String转化成num，但是String确实不满足格式要求<br>ArithmeticException:除0错误</li>
<li>非runtimeException<br>ClassNotFoundException<br>I/OException</li>
<li>Error<br>NoClassDefFoundError:找不到class的定义，没有引入jar包<br>StackOverflowError:深递归导致方法调用栈被耗尽<br>OutOfMemoryError:内存溢出异常<br>##Java的异常处理机制</li>
<li>抛出异常<br>创建异常对象，交由运行时系统处理</li>
<li>捕获异常<br>寻找合适的异常处理器进行处理，如果没有找到，则终止程序<br>##Java异常处理流程</li>
<li>在出现异常时，在堆上创建异常对象</li>
<li>当异常出现时，当前的执行路径将会被终止（不会执行try块中后续的逻辑代码）</li>
<li>然后会抛出异常对象的引用</li>
<li>抛出的异常会被catch捕获，子类在前面就是子类子类捕获</li>
<li>catch中的return之前，会先执行finally子句中的语句，如果finally子句中出现了return，则不会再回到catch中执行那个return了</li>
<li>异常至多被一个catch匹配到，且匹配按照先后顺序进行匹配<br>##Java异常处理原则<br>具体明确、提早抛出、延迟捕获（让掌握更多信息的作用域去处理异常）<br>try-catch需要创建异常对象实例，保存栈快照，开销较大。所以尽量用try包裹一场出现的代码段<br>##Java throws和try-catch的区别</li>
<li>throws是向上抛出，将异常交给方法的调用方来处理异常</li>
<li>try-catch是捕获异常，自己处理异常<h2 id="ClassNotFoundException-VS-NotClassDefFundError"><a href="#ClassNotFoundException-VS-NotClassDefFundError" class="headerlink" title="ClassNotFoundException VS NotClassDefFundError"></a>ClassNotFoundException VS NotClassDefFundError</h2></li>
<li>ClassNotFound是因为在加载类时，找不到定义的class代码段，没有在内存中生成对应的类对象</li>
<li>NotClassDefFoundError时Error，编译能够通过，但是new对象时找不到类的定义而出错。可能原因：找不到class文件、class文件在不同的域中（在当前的java path下不可用，java path是我们配置环境变量时看到的那个东西）</li>
</ol>
<p>#Java底层</p>
<p>##平台无关性</p>
<ol>
<li>一次编译，到处运行，可以使用javac指令将java代码编译成.class字节码，让后用java指令运行程序</li>
<li>不同平台的JVM会解析字节码，将其转化成不同平台上的指令</li>
<li>引入字节码：防止每一次词法、语法、语义的检查工作，多次执行不需要做重复工作，提高性能</li>
<li>引入字节码还可以兼容别的语言，例如Ruby，也是可以编译成字节码，然后在JVM中执行</li>
</ol>
<p>##Java虚拟机</p>
<ol>
<li>屏蔽底层的不同，让程序员可以专注写java代码</li>
<li>JVM是内存中的虚拟机，JVM的存储就是内存<br><img src="/2020/06/19/java-foundamental/jvm.png" alt=""></li>
<li>JVM大致可以分为4个部分，class Loader、Runtime Data Area、Execution Engine、Native Interface</li>
<li>ClassLoader的作用是将编译好的class文件加载到内存，加载时依据特定的文件格式</li>
<li>Execution起到解释器的作用，解析class文件中的字节码，并提交给操作系统去执行</li>
<li>Native Interface融合不同开发语言的原生库来提供给Java使用，避免重复造轮子、提高执行效率<br>ps:Java在大多数情况下执行效率没有原生的C高，forName函数就是通过字符串来找到指定的类，调用了native接口</li>
<li>Runtime Data Area:JVM内存模型</li>
</ol>
<p>##Java反射</p>
<ol>
<li>动态获取信息、动态调用对象方法</li>
<li>在运行状态中，对于任意一个类，能够知道这个类的所有属性和方法；对于任意一个对象，能够知道调用这个对象中的任意属性和方法</li>
<li>java反射就是将java中的各种函数映射成对象：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//先用forName获取到class对象</span><br><span class="line">Class rc = Class.forName(<span class="string">"..."</span>);</span><br><span class="line">rc.getName();</span><br><span class="line">Method myMethod = rc.getMethod();</span><br><span class="line">Field myField = rc.getDeclaredField();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>##类从编译到执行的过程</p>
<ol>
<li>编译器：编译器将Student.java编译成Student.class字节码</li>
<li>ClassLoader:ClassLoader将字节码转换为JVM中的Class<student>对象</student></li>
<li>JVM:JVM利用Class<student>对象实例化Student对象</student></li>
</ol>
<p>##ClassLoader</p>
<ol>
<li>ClassLoader是一个抽象类，比较重要的方法是loadClass</li>
<li>loadClass接收字符串参数，返回class实例；如果找不到类，就向上抛出一个ClassNotFound的Exception</li>
<li>ClassLoader种类<br>3.1 BootStrapClassLoader:C++编写，用于加载核心库java.<em><br>3.2 ExtClassLoader:Java编写，用于加载扩展库javax.</em><br>3.3 AppClassLoader:Java编写，用于加载程序所在目录<br>3.4 自定义ClassLoader:Java编写，定制化加载</li>
<li>如果要自定义ClassLoader，就需要重写重写findClass找到文件，然后在defineClass中生成class对象</li>
<li>.java-&gt;.class-&gt;class对象</li>
</ol>
<p>##ClassLoader的双亲委派机制<br>先寻找类对象，按照customClassLoader-&gt;AppClassLoader-&gt;ExtClassLoader-&gt;BootsrapClassLoader的顺序查看是否已经加载该类（自底向上找class对象）<br>再找文件，按照BootstrapClassLoader-&gt;ExtClassLoader-&gt;AppClassLoader-&gt;CustomClassLoader<br>目的：防止多份同样字节码的加载</p>
<p>##类的加载方式</p>
<ol>
<li>隐式加载：new，程序在运行过程中使用new隐式调用对应的类加载器</li>
<li>显式加载，通过loadClass、forName显式加载类，获得类对象，再用newInstance获得实例</li>
<li>forName得到的类对象是完成了初始化的，loadClass得到的类是完成了链接的</li>
<li>forName的初始化特性可以帮助我们加载一些具有静态代码块的Driver；loadClass可以加速类的加载，初始化用到再说</li>
<li>类的装载过程：加载（ClassLoader加载字节码）、链接（校验、类变量分配空间、符号引用转换为直接引用）、初始化（类变量赋值、静态代码块）</li>
</ol>
<p>#JVM内存模型（JDK8后）</p>
<ol>
<li>计算机所有程序都是在内存中运行的</li>
<li>32位处理器可寻址空间，2^32；64位处理器可寻址空间，2^64</li>
<li><p>内存需要将物理地址映射为逻辑地址；内存寻址空间的划分：内核空间、用户空间。JVM运行在用户空间。</p>
</li>
<li><p>线程私有：程序计数器、虚拟机栈、本地方法栈</p>
</li>
<li>所有线程共享：MeataSpace、堆（包含字符串常量池，String str = “123”;）</li>
</ol>
<p>##1.程序计数器</p>
<ol>
<li>JVM的多线程是通过线程轮流切换，分配处理器的方式进行的，所以程序计数器和线程是一对一的关系</li>
<li>程序计数器是当前线程所执行的字节码指令的行号指示器</li>
<li>改变计数器的值来选取下一条需要执行的字节码指令</li>
<li>说白了，程序计数器告诉对应的线程要去执行哪一条字节码指令</li>
<li>只对线程执行的java方法计数，不对Native方法计数</li>
<li>不会发生内存泄漏的问题</li>
<li>程序计数器是逻辑计数器，帮助线程执行完成后能够恢复到正确的位置</li>
</ol>
<p>##2.Java虚拟机栈<br>包含单个线程每个方法执行的栈帧，栈帧中包含了局部变量表、操作数栈、动态连接、返回地址</p>
<ol>
<li>局部变量表：包含方法执行过程中的所有变量（this引用、所有方法参数、局部变量）</li>
<li>操作数栈：在执行字节码指令过程中会用到，展现赋值、计算过程中的操作数的出入栈过程</li>
<li>istore弹出操作数栈，iload压入操作数栈</li>
<li>虚拟机栈是JVM自动管理的，有固定容量的，里面存储栈帧</li>
<li>调用方法时栈帧自动压栈，调用结束，栈帧自动释放出栈，所以栈中内存不需要GC去回收，而会自动释放。</li>
</ol>
<p>##Java为什么会产生stackoverflow的异常？<br>线程调用方法时，会向虚拟机栈中压入栈帧，方法执行完毕，再将栈帧弹出<br>虚拟机栈的深度是固定的，当递归层数过多，栈桢数超过虚拟机栈深度，就会发生stackoverflowError<br>ps:解决方式：减少递归层数；使用循环替代递归</p>
<p>##虚拟机栈过多引发OutOfMemoryError<br>虚拟机栈的动态扩展时，无法申请到足够多的内存<br>e.g.无限创造线程</p>
<p>##3.本地方法栈<br>作用与虚拟机栈类似，主要作用于Native方法 e.g. forName0(C++编写)</p>
<p>##4.MetaSpace(线程共享部分)<br>存放Java类的元数据，包括class对象的field和method<br>元空间使用本地内存，而非jvm内存<br>替代了原本的方法区，静态变量所在的地方</p>
<p>##5. Java堆（线程共享部分）</p>
<ol>
<li>存放对象实例，为对象实例分配内存，当内存不足时，会抛出outOfMemory的异常</li>
<li>GC的主要管理区域</li>
<li>还包含常量池，内含字面量和符号引用量</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/19/java-foundamental/" data-id="ckc4v5z2k000r7wwz8a0941aa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-动态规划" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/18/动态规划/" class="article-date">
  <time datetime="2020-06-18T15:09:02.000Z" itemprop="datePublished">2020-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/18/动态规划/">动态规划</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#爬楼梯</p>
<ol>
<li>动态规划实质上就是一个递推的过程</li>
<li>先研究基本情况，再找出基本情况和之后情况的递推关系</li>
<li>本题中的地推情况就是dp[i]=dp[i-1]+dp[i-2]</li>
<li>创建dp数组时，应该是n+1的长度，然后从1开始</li>
</ol>
<p>#打家劫舍</p>
<ol>
<li>设置边界值</li>
<li>设置dp数组，初始条件</li>
<li>for循环+状态方程 max的关系</li>
<li>return dp[n]<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int rob(int[] nums) &#123;</span><br><span class="line">       <span class="keyword">if</span>(nums.length == 0)&#123;</span><br><span class="line">           <span class="built_in">return</span> 0;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(nums.length == 1)&#123;</span><br><span class="line">           <span class="built_in">return</span> nums[0];</span><br><span class="line">       &#125;</span><br><span class="line">       int[] dp = new int[nums.length];</span><br><span class="line">       dp[0] = nums[0];</span><br><span class="line">       dp[1] = Math.max(dp[0],nums[1]);</span><br><span class="line">       <span class="keyword">for</span>(int i=2;i&lt;nums.length;i++)&#123;</span><br><span class="line">           dp[i] = Math.max(nums[i]+dp[i-2],dp[i-1]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">return</span> dp[nums.length-1];        </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>##最大子段和</p>
<ol>
<li>需要注意的地方：因为要求是连续，所以当前的元素必须要选，之后只能做放弃前面or追加这两种选择</li>
<li>最终结果并不一定是最优解，结果会出现在中间，所以用一个max变量去打擂台<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == 0)&#123;</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == 1)&#123;</span><br><span class="line">            <span class="built_in">return</span> nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        int max_res = dp[0];</span><br><span class="line">        <span class="keyword">for</span>(int i=1;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i-1]&gt;0)&#123;</span><br><span class="line">                dp[i] = dp[i-1]+nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max_res &lt; dp[i])&#123;</span><br><span class="line">                max_res = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> max_res;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>##最长回文数</p>
<ol>
<li>特殊情况：空字符串、null指针</li>
<li>边界条件：单字符、双字符情况，3字符以上可以进入循环使用状态方程</li>
<li>状态方程：dp[i][j] = j-i&lt;2&amp;&amp;s[i]==s[j] 或者 dp[i][j] = dp[i+1][j-1]&amp;&amp;s[i]==s[j]</li>
<li>从最后一个不断向前，每次内循环向后扫描</li>
<li>使用HashMap记录下长度和值的对应关系，最后用最大的长度去取值并返回</li>
<li>i、j是两个字符串指针，i左j右<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">       <span class="keyword">if</span>(s == null || s.equals(<span class="string">""</span>))&#123;</span><br><span class="line">           <span class="built_in">return</span> s;</span><br><span class="line">       &#125;</span><br><span class="line">       boolean[][] dp = new boolean[s.length()][s.length()];</span><br><span class="line">       int max = 0;</span><br><span class="line">       HashMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(int i = s.length()-1;i&gt;=0;i--)&#123;</span><br><span class="line">           <span class="keyword">for</span>(int j=i;j&lt;s.length();j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                   <span class="keyword">if</span>(j-i&lt;2)&#123;</span><br><span class="line">                       dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span>(dp[i+1][j-1])&#123;</span><br><span class="line">                       dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(dp[i][j]&amp;&amp;max&lt;j-i+1)&#123;</span><br><span class="line">                   max = j-i+1;</span><br><span class="line">                   map.put(max,s.substring(i,j+1));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">return</span> map.get(max);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/18/动态规划/" data-id="ckc4v5z2s000z7wwz0znujyxa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-二叉树" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/18/二叉树/" class="article-date">
  <time datetime="2020-06-18T10:40:46.000Z" itemprop="datePublished">2020-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/18/二叉树/">二叉树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#二叉树遍历<br>前序遍历：从根节点开始，默念“中左右”，对于每一个结点都同样适用，第一个是根节点<br>中序遍历：从根节点开始，默念“左中右”，对于每一个结点都同样适用<br>后序遍历：从根节点开始，默念“左右中”，对于每一个结点都同样适用，最后一个是根节点</p>
<p>#二叉树的结点与深度的关系<br>深度h，结点数n<br>对于满二叉树：2^h-1=n<br>对于完全二叉树：n=floor(log(n)/log(2))+1</p>
<p>ps:Scanner的next和nextLine的区别<br>next:从第一个有效字符开始，到非有效字符结束<br>nextLine:Enter之前的全部字符</p>
<p>#获取二叉树的深度</p>
<ol>
<li>使用前序遍历的架构</li>
<li>如果当前的结点是null，直接返回0</li>
<li>当前结点不是null，左右分别递归调用</li>
<li>返回的是这一层回溯中的最大值+1，这样回溯了几层就加了几<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static int getDepth(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==null)&#123;</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            int left = getDepth(root.left);</span><br><span class="line">            int right = getDepth(root.right);</span><br><span class="line">            //每层回溯+1</span><br><span class="line">            <span class="built_in">return</span> Math.max(left,right)+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/18/二叉树/" data-id="ckc4v5z2r000x7wwzg1tzaocq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-全排列" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/18/全排列/" class="article-date">
  <time datetime="2020-06-18T08:16:23.000Z" itemprop="datePublished">2020-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/18/全排列/">全排列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p>回溯法的应用，因为排列要求不能重复，只是位置更换<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">backtrack&#123;</span><br><span class="line">    <span class="keyword">if</span> 满足条件</span><br><span class="line">       结果.add(路径)</span><br><span class="line">       <span class="built_in">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(选择:选择列表)&#123;</span><br><span class="line">        做出选择</span><br><span class="line">        backtrack(路径，选择列表)</span><br><span class="line">        撤销选择</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>list的add方法，参数是元素，加在最后面<br>list的remove方法，参数是索引</p>
<ol>
<li>如果list的长度到位，则将这次的结果交给res</li>
<li>从选择列表中选择元素，加一个条件，对列表中没有的元素才执行操作</li>
<li>选择方式：加到列表中</li>
<li>重新调用（重新调用能完成一种情况的列举）</li>
<li>去掉这个元素，重新开始另一个循环，一零一个元素为开头<br>总结：循环{加入、递归、去除}<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; element = new ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(result,element,nums);</span><br><span class="line">        <span class="built_in">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void backtrack(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list, int[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == nums.length)&#123;</span><br><span class="line">            result.add(new ArrayList&lt;Integer&gt;(list));</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(num))&#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">                backtrack(result,list,nums);</span><br><span class="line">                list.remove(list.size()-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>字符串长度.length()<br>数组长度.length<br>List长度.size()</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/18/全排列/" data-id="ckc4v5z2q000w7wwzv42govtv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-链表题" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/17/链表题/" class="article-date">
  <time datetime="2020-06-17T13:57:37.000Z" itemprop="datePublished">2020-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/链表题/">链表题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>链表题随时要清楚，每一个操作的节点都不能丢,从这一点出发去设计指针，考虑先后顺序</p>
<h1 id="ReverseList"><a href="#ReverseList" class="headerlink" title="ReverseList"></a>ReverseList</h1><ol>
<li>设置三个指针，prev指向null,curr指向第一个节点,temp指向第二个节点</li>
<li>curr的next指向prev</li>
<li>prev指向curr</li>
<li>curr指向temp</li>
<li>temp指向temp.next<br>相当于从一个链表向另一个链表中迁移<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ListNode prev = null;</span><br><span class="line">        //用指针curr记住第一个</span><br><span class="line">        ListNode curr = list;</span><br><span class="line">        ListNode temp = null;</span><br><span class="line">        <span class="keyword">while</span>(curr!=null)&#123;</span><br><span class="line">            temp = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> prev;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="mergeList"><a href="#mergeList" class="headerlink" title="mergeList"></a>mergeList</h1><ol>
<li>设置一个头结点，用head、p3分别指着</li>
<li>输入的两个链表分别用p1、p2指着</li>
<li>之后是类似于归并排序一样，进行三个while的操作</li>
<li>链表的归并最后的单独讨论不需要用while，if就好，并且只要让一处的指针只想完毕就好，后续不必重复执行动作<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static ListNode mergeList(ListNode list1, ListNode list2)&#123;</span><br><span class="line">        ListNode p1=null,p2=null;</span><br><span class="line">        p1=list1;p2=list2;</span><br><span class="line">        //设置一个头结点解决问题</span><br><span class="line">        ListNode head = new ListNode();</span><br><span class="line">        ListNode p3 =head;</span><br><span class="line">        <span class="keyword">while</span>(p1!=null &amp;&amp; p2!=null)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.val&lt;=p2.val)&#123;</span><br><span class="line">                p3.next = p1;</span><br><span class="line">                p1=p1.next;</span><br><span class="line">                p3=p3.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p3.next = p2;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">                p3 = p3.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1!=null)&#123;</span><br><span class="line">            p3.next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2!=null)&#123;</span><br><span class="line">            p3.next=p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> head.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>#相交链表</p>
<p>##解法一：暴力法</p>
<ol>
<li>分别用链表A的每一个元素去扫描链表B的每一个元素，发现相同的就返回，这种方式复杂度为O(n^2)</li>
<li>需要注意的一点是，链表的遍历是一趟的，所以为了让链表B能够多趟遍历，要在外层循环中手动把指针指向链表B的头<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode pa = headA,pb = headB;</span><br><span class="line">        <span class="keyword">while</span>(pa!=null)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pb!=null)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pa == pb)&#123;</span><br><span class="line">                    <span class="built_in">return</span> pa;</span><br><span class="line">                &#125;</span><br><span class="line">                pb = pb.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pb = headB;</span><br><span class="line">            pa=pa.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> null;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>##解法二：gap法</p>
<ol>
<li>先统计两个链表的长度</li>
<li>通过长度做差，使得两个指针指向等长的位置</li>
<li>齐头并进往前遍历，相同就返回<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        ListNode pa = headA, pb = headB;</span><br><span class="line">        int lenA = getLength(headA);</span><br><span class="line">        int lenB = getLength(headB);</span><br><span class="line">        <span class="keyword">if</span>(lenA&gt;=lenB)&#123;</span><br><span class="line">            int gap = lenA-lenB;</span><br><span class="line">            <span class="keyword">while</span>(gap &gt; 0)&#123;</span><br><span class="line">            pa = pa.next;</span><br><span class="line">            gap--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            int gap = lenB - lenA;</span><br><span class="line">            <span class="keyword">while</span>(gap&gt;0)&#123;</span><br><span class="line">                pb = pb.next;</span><br><span class="line">                gap--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pa!=null &amp;&amp; pb!=null)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pa==pb)&#123;</span><br><span class="line">                <span class="built_in">return</span> pa;</span><br><span class="line">            &#125;</span><br><span class="line">            pa = pa.next;</span><br><span class="line">            pb = pb.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getLength(ListNode head)&#123;</span><br><span class="line">        int count=0;</span><br><span class="line">        <span class="keyword">while</span>(head!=null)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>#链表归并排序</p>
<ol>
<li>只接受一个链表作为参数，首先排除特殊情况：链表为空和链表只有一个元素时，直接返回head</li>
<li>通过快慢指针找到链表的中间结点（满指针一次过一个，快指针一次过两个；快指针的循环截止体哦阿健要考虑到两种情况）</li>
<li>对右侧进行递归</li>
<li>中间一刀两段 slowp.next = null;</li>
<li>对左侧进行递归</li>
<li>将左右两边merge并返回</li>
<li>merge就是普通的链表merge，定义一个头结点，一个while两个if，完美解决<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode sortList(ListNode head) &#123;</span><br><span class="line">        //快速处理特殊情况</span><br><span class="line">        <span class="keyword">if</span>(head == null || head.next == null)&#123;</span><br><span class="line">            <span class="built_in">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slowp = head;</span><br><span class="line">        ListNode fastp = head.next.next;</span><br><span class="line">        ListNode left=null,right=null;</span><br><span class="line">        //找到链表的中间结点</span><br><span class="line">        <span class="keyword">while</span>(fastp != null &amp;&amp; fastp.next != null)&#123;</span><br><span class="line">            slowp = slowp.next;</span><br><span class="line">            fastp = fastp.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        right = sortList(slowp.next);</span><br><span class="line">        slowp.next = null;</span><br><span class="line">        left = sortList(head);</span><br><span class="line">        <span class="built_in">return</span> merge(left,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static ListNode merge(ListNode left, ListNode right)&#123;</span><br><span class="line">        //头结点</span><br><span class="line">        ListNode tempHead = new ListNode();</span><br><span class="line">        ListNode p1=left,p2=right,p3=tempHead;</span><br><span class="line">        <span class="keyword">while</span>(p1!=null &amp;&amp; p2!=null)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.val&lt;=p2.val)&#123;</span><br><span class="line">                p3.next = p1;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p3.next = p2;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p3 = p3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1 != null)&#123;</span><br><span class="line">            p3.next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2 != null)&#123;</span><br><span class="line">            p3.next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> tempHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>#链表快速排序</p>
<ol>
<li>先排除特殊情况，再定义一个头结点，调用quickSort方法</li>
<li>quickSort方法接收head和end两种参数</li>
<li>先规定好basecase，包括head、head.next、head.next.next等于end的情况</li>
<li>然后创建一个临时头结点，用来暂管较小部分的链表</li>
<li>选择头结点后面的结点（第一个有效结点作为主元），用pivot指针指着</li>
<li>定义一个p指针作为主链扫描指针，p先指着主元</li>
<li>以p.next!=null作为循环条件（主元扫描指针下一个元素不等于空）。主元的下一个元素，如果比主元小，就接到临时链上，由临时链上的扫描指针指着</li>
<li>如果比主元大，那么p扫描指针就向前一步</li>
<li>小链接大链 tp.next = head.next</li>
<li>头结点归位 head.next=tmpHead.next</li>
<li>递归调用 head pivot; pivot end</li>
<li>返回head.next<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static ListNode sort(ListNode head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == null || head.next == null)&#123;</span><br><span class="line">            <span class="built_in">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = new ListNode();</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        //连表的前后弦</span><br><span class="line">        <span class="built_in">return</span> quickSort(newHead,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里的head是指头结点</span><br><span class="line">    //用一个临时的结点作为存储小的部分的链表头结点</span><br><span class="line">    static ListNode quickSort(ListNode head, ListNode end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==end||head.next==end||head.next.next==end)&#123;</span><br><span class="line">            <span class="built_in">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tmpHead = new ListNode();</span><br><span class="line">        ListNode pivot = head.next;</span><br><span class="line">        ListNode p = pivot;</span><br><span class="line">        ListNode tp = tmpHead;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=null)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.next.val&lt;pivot.val)&#123;</span><br><span class="line">                tp.next = p.next;</span><br><span class="line">                p.next = p.next.next;</span><br><span class="line">                tp = tp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //将小串和大串接起来</span><br><span class="line">        tp.next = head.next;</span><br><span class="line">        //头结点归位</span><br><span class="line">        head.next = tmpHead.next;</span><br><span class="line">        quickSort(head,pivot);</span><br><span class="line">        quickSort(pivot,end);</span><br><span class="line">        <span class="built_in">return</span> head.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>#ReorderList<br>前面几道题的综合</p>
<ol>
<li>快慢指针找中间节点</li>
<li>分成两个结点</li>
<li>翻转第二个链表</li>
<li>合并两个链表<br>ps:任何时候都要注意个数少时（0、1、2）的特殊情况，上来先讨论<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void reorderList(ListNode head) &#123;</span><br><span class="line">        //考虑特殊情况下,0，1，2个元素</span><br><span class="line">        <span class="keyword">if</span>(head==null||head.next==null||head.next.next==null)&#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode slowp=head,fastp=head.next.next;</span><br><span class="line">        ListNode tempHead=null;</span><br><span class="line">        <span class="keyword">while</span>(fastp!=null &amp;&amp; fastp.next!=null)&#123;</span><br><span class="line">            slowp = slowp.next;</span><br><span class="line">            fastp = fastp.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tempHead = slowp.next;</span><br><span class="line">        slowp.next = null;</span><br><span class="line"></span><br><span class="line">        ListNode prev = null,temp=null;</span><br><span class="line">        ListNode curr = tempHead;</span><br><span class="line">        <span class="keyword">while</span>(curr != null)&#123;</span><br><span class="line">            temp = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode fakeHead = new ListNode();</span><br><span class="line">        ListNode p1=head,p2=prev,p3=fakeHead;</span><br><span class="line">        <span class="keyword">while</span>(p1!=null &amp;&amp; p2!=null)&#123;</span><br><span class="line">            p3.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p3 = p3.next;</span><br><span class="line">            p3.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            p3 = p3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1 != null)&#123;</span><br><span class="line">            p3.next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2 != null)&#123;</span><br><span class="line">            p3.next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="检查链表是否有环"><a href="#检查链表是否有环" class="headerlink" title="检查链表是否有环"></a>检查链表是否有环</h1><h2 id="方法一：使用HashSet检查重复元素"><a href="#方法一：使用HashSet检查重复元素" class="headerlink" title="方法一：使用HashSet检查重复元素"></a>方法一：使用HashSet检查重复元素</h2><p>遍历链表，如果结点不在set中，则加入其中；如果结点在set中，则返回有环<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        Set&lt;ListNode&gt; <span class="built_in">set</span> = new HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head != null)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(head))&#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(head);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法二：快慢指针同时起跑"><a href="#方法二：快慢指针同时起跑" class="headerlink" title="方法二：快慢指针同时起跑"></a>方法二：快慢指针同时起跑</h2><h1 id="链表以k为分组进行反转"><a href="#链表以k为分组进行反转" class="headerlink" title="链表以k为分组进行反转"></a>链表以k为分组进行反转</h1><p>ps：注意java中的对象参数类似于指针，java没有引用</p>
<ol>
<li>设置四个指针tempHead、prev、curr、next</li>
<li>tempHead是整个链表的头结点指针，prev相当于是每个分组的头结点指针</li>
<li>curr指向每个分组的第一个结点，next指向curr结点之后的结点</li>
<li>首先获得链表的长度</li>
<li>设置两层for循环，第一层循环的上限分组数</li>
<li>内层循环是反转一个分组所需要的操作数，k=1时0，k=2时1，所以最多执行k-1次</li>
<li>具体操作是让next先指向curr之后的位置，curr指向next之后的结点防止断链，next插入到prev后面<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int length = 0;</span><br><span class="line">        //设置一个头结点</span><br><span class="line">        ListNode tempHead = new ListNode();</span><br><span class="line">        tempHead.next = head;</span><br><span class="line">        //设置每个分组的头结点指针</span><br><span class="line">        ListNode prev = tempHead;</span><br><span class="line">        //设置当前结点指针</span><br><span class="line">        ListNode curr = prev.next;</span><br><span class="line">        //设置后续指针</span><br><span class="line">        ListNode next = null;</span><br><span class="line">        //为了方便分组，需要知道数组的长度</span><br><span class="line">        <span class="keyword">while</span>(curr!=null)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //记得指针归位</span><br><span class="line">        curr = prev.next;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;length/k;i++)&#123;</span><br><span class="line">            //外层循环分组</span><br><span class="line">            <span class="keyword">for</span>(int j=0;j&lt;k-1;j++)&#123;</span><br><span class="line">                //内层规定操作次数</span><br><span class="line">                //在这个区域内做一个反转</span><br><span class="line">                next = curr.next;</span><br><span class="line">                curr.next = next.next;</span><br><span class="line">                next.next = prev.next;</span><br><span class="line">                prev.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> tempHead.next;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这也为普通的重排链表提供了新思路，设置一个头结点、并获取到链表长度，将第一个节点后面的节点不断的插入到头结点的后面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode tempHead = new ListNode();</span><br><span class="line">        tempHead.next = head;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        ListNode next = null;</span><br><span class="line">        int length = 0;</span><br><span class="line">        <span class="keyword">while</span>(curr!=null)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;length-1;i++)&#123;</span><br><span class="line">            next = curr.next;</span><br><span class="line">            curr.next = next.next;</span><br><span class="line">            next.next = tempHead.next;</span><br><span class="line">            tempHead.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> tempHead.next;</span><br></pre></td></tr></table></figure></p>
<h1 id="MergeKSortedList"><a href="#MergeKSortedList" class="headerlink" title="MergeKSortedList"></a>MergeKSortedList</h1><h2 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h2><ol>
<li>将输入链表的值都存储到一个数组中</li>
<li>对这个数组进行快排操作</li>
<li>将这个数组构造成链表<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class="line">        //将三个链表的数据都存到一个数组中</span><br><span class="line">        int[] arr = new int[getLength(lists[0])+getLength(lists[1])+getLength(lists[2])];</span><br><span class="line">        int i = 0;</span><br><span class="line">        <span class="keyword">for</span>(int j=0;j&lt;lists.length;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(lists[j]!=null)&#123;</span><br><span class="line">                arr[i] = lists[j].val;</span><br><span class="line">                lists[j] = lists[j].next;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //对数组进行排序</span><br><span class="line">        quickSort(arr,0,arr.length-1);</span><br><span class="line">        System.out.println(<span class="string">"数组结果"</span>);</span><br><span class="line">        <span class="keyword">for</span>(int a : arr)&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">        //将数组变成链表</span><br><span class="line">        <span class="built_in">return</span> createList(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取链表长度</span><br><span class="line">    static int getLength(ListNode list)&#123;</span><br><span class="line">        int length = 0;</span><br><span class="line">        <span class="keyword">while</span>(list != null)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            list = list.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //快速排序</span><br><span class="line">    static void quickSort(int[] data,int low,int high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">            int pivotIndex = partition(data,low,high);</span><br><span class="line">            quickSort(data,low,pivotIndex-1);</span><br><span class="line">            quickSort(data,pivotIndex+1,high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int partition(int[] data,int low,int high)&#123;</span><br><span class="line">        int pivot = data[low];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; data[high]&gt;=pivot)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            data[low] = data[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; data[low]&lt;=pivot)&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            data[high] = data[low];</span><br><span class="line">        &#125;</span><br><span class="line">        data[low] = pivot;</span><br><span class="line">        <span class="built_in">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static ListNode createList(int[] data)&#123;</span><br><span class="line">        ListNode head = new ListNode(data[data.length-1]);</span><br><span class="line">        <span class="keyword">for</span>(int i=data.length-2;i&gt;=0;i--)&#123;</span><br><span class="line">            ListNode temp = new ListNode(data[i],head);</span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="方法二：常规merge"><a href="#方法二：常规merge" class="headerlink" title="方法二：常规merge"></a>方法二：常规merge</h2><h2 id="方法三：优先队列"><a href="#方法三：优先队列" class="headerlink" title="方法三：优先队列"></a>方法三：优先队列</h2><h2 id="方法四：归并"><a href="#方法四：归并" class="headerlink" title="方法四：归并"></a>方法四：归并</h2><p>#删除倒数第N个结点<br>也是针对倒数…个的一些方法</p>
<p>##方法一：求链表长度<br>用while求出length，再用length减去n</p>
<p>##方法二：匀速间隔指针<br>单向链表，删除一般只需要被删除结点前面的那个节点<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">        ListNode tempHead = new ListNode();</span><br><span class="line">        tempHead.next = head;</span><br><span class="line">        ListNode prev = tempHead;</span><br><span class="line">        ListNode curr = tempHead;</span><br><span class="line">        //指向第n+1个</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(curr != null)&#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //此时prev在倒数第n个结点前面那个结点</span><br><span class="line">        prev.next = prev.next.next;</span><br><span class="line">        <span class="built_in">return</span> tempHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/17/链表题/" data-id="ckc4v5z2w00137wwzalno7vx5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/02/Java-I-O/">Java-I/O</a>
          </li>
        
          <li>
            <a href="/2020/07/01/Android提升/">Android提升</a>
          </li>
        
          <li>
            <a href="/2020/06/30/KMP算法/">KMP算法</a>
          </li>
        
          <li>
            <a href="/2020/06/28/Java常用类库/">Java常用类库</a>
          </li>
        
          <li>
            <a href="/2020/06/28/Android总结/">Android总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>