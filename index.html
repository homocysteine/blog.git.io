<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Homocysteine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Homocysteine">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Homocysteine">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Homocysteine">
  
    <link rel="alternate" href="/atom.xml" title="Homocysteine" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Homocysteine</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java-foundamental" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/19/java-foundamental/" class="article-date">
  <time datetime="2020-06-19T03:46:03.000Z" itemprop="datePublished">2020-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/19/java-foundamental/">java foundamental</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java参数传递"><a href="#Java参数传递" class="headerlink" title="Java参数传递"></a>Java参数传递</h1><ol>
<li>基础数据类型是值传递</li>
<li>对象类型，实参和形参指向同一片内存，但是如果更改形参指向，不会影响实参</li>
<li>指针和引用还是有区别的，指针无法改变指向</li>
</ol>
<h1 id="Java继承"><a href="#Java继承" class="headerlink" title="Java继承"></a>Java继承</h1><ol>
<li>子类可以继承父类的 所有 属性和方法，还可以重写父类的方法，但是私有的是不能调用的</li>
<li>Object类是层次结构的根，java所有类都继承自这个类</li>
<li>构造子类对象前，要先构造父类对象，用super关键字实现</li>
<li>子类带参要先调父类带参</li>
<li>子类咔嚓一下就可以转换成父类，这是安全的，转换成谁，谁在左边</li>
<li>父类转换成子类时，需要用（）来实现强制转换</li>
<li>接口只有静态常量和抽象方法，十分抽象的类</li>
<li>定义接口是帮助子类进行扩展</li>
<li>Java只允许单继承，降低复杂性，但是可以实现多个接口；C++允许多继承</li>
</ol>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ol>
<li>static修饰类，只能修饰内部类</li>
<li>static修饰的方法可以通过类名来直接调用</li>
<li>static修饰的变量属于类，可以通过类名直接调用</li>
<li>类初始化顺序：先父类，后子类；先静态和非静态</li>
<li>父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数</li>
<li>java的对象放在堆区，线程共享；其它放在栈区，每个线程有一个</li>
<li>类和静态区存放在静态区，线程共享</li>
<li>静态随类，非静态随对象，所以静态方法中无法使用this、super</li>
</ol>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><ol>
<li>final修饰类，则这个类不能被继承</li>
<li>final修饰方法，则这个方法不能被重写</li>
<li>final修饰基础类型变量，必须初始化，且只能初始化一次</li>
<li>final修饰对象类型变量，地址不能变</li>
</ol>
<h1 id="java编程知识积累"><a href="#java编程知识积累" class="headerlink" title="java编程知识积累"></a>java编程知识积累</h1><ol>
<li>java数组为null和空数组是不一样的概念。null表示这个对象引用是一个空引用；空数组表示是一个真正的对象，只不过元素数量为0</li>
</ol>
<h1 id="java异常"><a href="#java异常" class="headerlink" title="java异常"></a>java异常</h1><h2 id="java异常体系主要回答的三个问题"><a href="#java异常体系主要回答的三个问题" class="headerlink" title="java异常体系主要回答的三个问题"></a>java异常体系主要回答的三个问题</h2><p>what:异常类型回答了什么被抛出<br>where:异常堆栈跟踪回答了在哪里被抛出<br>why:异常信息回答了为什么会被抛出</p>
<h2 id="java的异常体系"><a href="#java的异常体系" class="headerlink" title="java的异常体系"></a>java的异常体系</h2><p><img src="/2020/06/19/java-foundamental/java_foundamental/java_Exception.png" alt=""></p>
<ol>
<li>java异常的顶层父类是Throwable类，Throwable继承自Object类</li>
<li>Error:(JVM负责)程序无法处理的系统错误，编译器不做检查，遇到建议直接让程序终止 e.g. 系统崩溃、虚拟机错误、内存不足、方法调用栈溢出</li>
<li>Exception:程序可以处理的异常，捕获后可能修复，遇到应该尽可能去处理</li>
<li>Exception又可以分为runtimeException和非runtimeException</li>
<li>RuntimeException（程序负责）表示不可预知的，编译器不校验，程序应当进行避免 e.g.数组下标越界（outofIndex）、访问控制针(NullPointerException)</li>
<li>非runtimeException，（编译器负责）可以预知的错误，编译器校验的异常，不处理，程序不能被编译通过 I/OException、SQLException、ClassNotFound、EOFException<br>ps:java不能一个继承多个，但是可以一个被多个继承</li>
<li>尽量细化异常，不要泛化异常，因为一场本身就是为了方便定位问题的<h2 id="java常见Error和异常"><a href="#java常见Error和异常" class="headerlink" title="java常见Error和异常"></a>java常见Error和异常</h2></li>
<li>runtimeException<br>NullPointerException:在试图使用的对象是null<br>ClassCastException:不兼容类型之间的转换异常<br>IllegalArgumentException:传递非法参数的异常<br>IndexOutOfBoundsException:下标越界异常<br>NumberFormatException:将String转化成num，但是String确实不满足格式要求<br>ArithmeticException:除0错误</li>
<li>非runtimeException<br>ClassNotFoundException<br>I/OException</li>
<li>Error<br>NoClassDefFoundError:找不到class的定义，没有引入jar包<br>StackOverflowError:深递归导致方法调用栈被耗尽<br>OutOfMemoryError:内存溢出异常<h2 id="Java的异常处理机制"><a href="#Java的异常处理机制" class="headerlink" title="Java的异常处理机制"></a>Java的异常处理机制</h2></li>
<li>抛出异常<br>创建异常对象，交由运行时系统处理</li>
<li>捕获异常<br>寻找合适的异常处理器进行处理，如果没有找到，则终止程序<h2 id="Java异常处理流程"><a href="#Java异常处理流程" class="headerlink" title="Java异常处理流程"></a>Java异常处理流程</h2></li>
<li>在出现异常时，在堆上创建异常对象</li>
<li>当异常出现时，当前的执行路径将会被终止（不会执行try块中后续的逻辑代码）</li>
<li>然后会抛出异常对象的引用</li>
<li>抛出的异常会被catch捕获，子类在前面就是子类子类捕获</li>
<li>catch中的return之前，会先执行finally子句中的语句，如果finally子句中出现了return，则不会再回到catch中执行那个return了</li>
<li>异常至多被一个catch匹配到，且匹配按照先后顺序进行匹配<h2 id="Java异常处理原则"><a href="#Java异常处理原则" class="headerlink" title="Java异常处理原则"></a>Java异常处理原则</h2>具体明确、提早抛出、延迟捕获（让掌握更多信息的作用域去处理异常）<br>try-catch需要创建异常对象实例，保存栈快照，开销较大。所以尽量用try包裹一场出现的代码段</li>
</ol>
<p>#Java底层</p>
<p>##平台无关性</p>
<ol>
<li>一次编译，到处运行，可以使用javac指令将java代码编译成.class字节码，让后用java指令运行程序</li>
<li>不同平台的JVM会解析字节码，将其转化成不同平台上的指令</li>
<li>引入字节码：防止每一次词法、语法、语义的检查工作，多次执行不需要做重复工作，提高性能</li>
<li>引入字节码还可以兼容别的语言，例如Ruby，也是可以编译成字节码，然后在JVM中执行<br>##Java虚拟机</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/19/java-foundamental/" data-id="ckblw37ak000fggwzpxw907at" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-动态规划" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/18/动态规划/" class="article-date">
  <time datetime="2020-06-18T15:09:02.000Z" itemprop="datePublished">2020-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/18/动态规划/">动态规划</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#爬楼梯</p>
<ol>
<li>动态规划实质上就是一个递推的过程</li>
<li>先研究基本情况，再找出基本情况和之后情况的递推关系</li>
<li>本题中的地推情况就是dp[i]=dp[i-1]+dp[i-2]</li>
<li>创建dp数组时，应该是n+1的长度，然后从1开始</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/18/动态规划/" data-id="ckblw37at000mggwzrfp6c657" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-二叉树" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/18/二叉树/" class="article-date">
  <time datetime="2020-06-18T10:40:46.000Z" itemprop="datePublished">2020-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/18/二叉树/">二叉树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#二叉树遍历<br>前序遍历：从根节点开始，默念“中左右”，对于每一个结点都同样适用，第一个是根节点<br>中序遍历：从根节点开始，默念“左中右”，对于每一个结点都同样适用<br>后序遍历：从根节点开始，默念“左右中”，对于每一个结点都同样适用，最后一个是根节点</p>
<p>#二叉树的结点与深度的关系<br>深度h，结点数n<br>对于满二叉树：2^h-1=n<br>对于完全二叉树：n=floor(log(n)/log(2))+1</p>
<p>ps:Scanner的next和nextLine的区别<br>next:从第一个有效字符开始，到非有效字符结束<br>nextLine:Enter之前的全部字符</p>
<p>#获取二叉树的深度</p>
<ol>
<li>使用前序遍历的架构</li>
<li>如果当前的结点是null，直接返回0</li>
<li>当前结点不是null，左右分别递归调用</li>
<li>返回的是这一层回溯中的最大值+1，这样回溯了几层就加了几<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static int getDepth(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==null)&#123;</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            int left = getDepth(root.left);</span><br><span class="line">            int right = getDepth(root.right);</span><br><span class="line">            //每层回溯+1</span><br><span class="line">            <span class="built_in">return</span> Math.max(left,right)+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/18/二叉树/" data-id="ckblw37aq000kggwzy866jilu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-全排列" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/18/全排列/" class="article-date">
  <time datetime="2020-06-18T08:16:23.000Z" itemprop="datePublished">2020-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/18/全排列/">全排列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p>回溯法的应用，因为排列要求不能重复，只是位置更换<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">backtrack&#123;</span><br><span class="line">    <span class="keyword">if</span> 满足条件</span><br><span class="line">       结果.add(路径)</span><br><span class="line">       <span class="built_in">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(选择:选择列表)&#123;</span><br><span class="line">        做出选择</span><br><span class="line">        backtrack(路径，选择列表)</span><br><span class="line">        撤销选择</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>list的add方法，参数是元素，加在最后面<br>list的remove方法，参数是索引</p>
<ol>
<li>如果list的长度到位，则将这次的结果交给res</li>
<li>从选择列表中选择元素，加一个条件，对列表中没有的元素才执行操作</li>
<li>选择方式：加到列表中</li>
<li>重新调用（重新调用能完成一种情况的列举）</li>
<li>去掉这个元素，重新开始另一个循环，一零一个元素为开头<br>总结：循环{加入、递归、去除}<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; element = new ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(result,element,nums);</span><br><span class="line">        <span class="built_in">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void backtrack(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list, int[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == nums.length)&#123;</span><br><span class="line">            result.add(new ArrayList&lt;Integer&gt;(list));</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(num))&#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">                backtrack(result,list,nums);</span><br><span class="line">                list.remove(list.size()-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>字符串长度.length()<br>数组长度.length<br>List长度.size()</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/18/全排列/" data-id="ckblw37as000lggwz95hqseaq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-链表题" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/17/链表题/" class="article-date">
  <time datetime="2020-06-17T13:57:37.000Z" itemprop="datePublished">2020-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/链表题/">链表题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>链表题随时要清楚，每一个操作的节点都不能丢,从这一点出发去设计指针，考虑先后顺序</p>
<h1 id="ReverseList"><a href="#ReverseList" class="headerlink" title="ReverseList"></a>ReverseList</h1><ol>
<li>设置三个指针，prev指向null,curr指向第一个节点,temp指向第二个节点</li>
<li>curr的next指向prev</li>
<li>prev指向curr</li>
<li>curr指向temp</li>
<li>temp指向temp.next<br>相当于从一个链表向另一个链表中迁移<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ListNode prev = null;</span><br><span class="line">        //用指针curr记住第一个</span><br><span class="line">        ListNode curr = list;</span><br><span class="line">        ListNode temp = null;</span><br><span class="line">        <span class="keyword">while</span>(curr!=null)&#123;</span><br><span class="line">            temp = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> prev;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="mergeList"><a href="#mergeList" class="headerlink" title="mergeList"></a>mergeList</h1><ol>
<li>设置一个头结点，用head、p3分别指着</li>
<li>输入的两个链表分别用p1、p2指着</li>
<li>之后是类似于归并排序一样，进行三个while的操作</li>
<li>链表的归并最后的单独讨论不需要用while，if就好，并且只要让一处的指针只想完毕就好，后续不必重复执行动作<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static ListNode mergeList(ListNode list1, ListNode list2)&#123;</span><br><span class="line">        ListNode p1=null,p2=null;</span><br><span class="line">        p1=list1;p2=list2;</span><br><span class="line">        //设置一个头结点解决问题</span><br><span class="line">        ListNode head = new ListNode();</span><br><span class="line">        ListNode p3 =head;</span><br><span class="line">        <span class="keyword">while</span>(p1!=null &amp;&amp; p2!=null)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.val&lt;=p2.val)&#123;</span><br><span class="line">                p3.next = p1;</span><br><span class="line">                p1=p1.next;</span><br><span class="line">                p3=p3.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p3.next = p2;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">                p3 = p3.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1!=null)&#123;</span><br><span class="line">            p3.next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2!=null)&#123;</span><br><span class="line">            p3.next=p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> head.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>#相交链表</p>
<p>##解法一：暴力法</p>
<ol>
<li>分别用链表A的每一个元素去扫描链表B的每一个元素，发现相同的就返回，这种方式复杂度为O(n^2)</li>
<li>需要注意的一点是，链表的遍历是一趟的，所以为了让链表B能够多趟遍历，要在外层循环中手动把指针指向链表B的头<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode pa = headA,pb = headB;</span><br><span class="line">        <span class="keyword">while</span>(pa!=null)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pb!=null)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pa == pb)&#123;</span><br><span class="line">                    <span class="built_in">return</span> pa;</span><br><span class="line">                &#125;</span><br><span class="line">                pb = pb.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pb = headB;</span><br><span class="line">            pa=pa.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> null;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>##解法二：gap法</p>
<ol>
<li>先统计两个链表的长度</li>
<li>通过长度做差，使得两个指针指向等长的位置</li>
<li>齐头并进往前遍历，相同就返回<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        ListNode pa = headA, pb = headB;</span><br><span class="line">        int lenA = getLength(headA);</span><br><span class="line">        int lenB = getLength(headB);</span><br><span class="line">        <span class="keyword">if</span>(lenA&gt;=lenB)&#123;</span><br><span class="line">            int gap = lenA-lenB;</span><br><span class="line">            <span class="keyword">while</span>(gap &gt; 0)&#123;</span><br><span class="line">            pa = pa.next;</span><br><span class="line">            gap--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            int gap = lenB - lenA;</span><br><span class="line">            <span class="keyword">while</span>(gap&gt;0)&#123;</span><br><span class="line">                pb = pb.next;</span><br><span class="line">                gap--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pa!=null &amp;&amp; pb!=null)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pa==pb)&#123;</span><br><span class="line">                <span class="built_in">return</span> pa;</span><br><span class="line">            &#125;</span><br><span class="line">            pa = pa.next;</span><br><span class="line">            pb = pb.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getLength(ListNode head)&#123;</span><br><span class="line">        int count=0;</span><br><span class="line">        <span class="keyword">while</span>(head!=null)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>#链表归并排序</p>
<ol>
<li>只接受一个链表作为参数，首先排除特殊情况：链表为空和链表只有一个元素时，直接返回head</li>
<li>通过快慢指针找到链表的中间结点（满指针一次过一个，快指针一次过两个；快指针的循环截止体哦阿健要考虑到两种情况）</li>
<li>对右侧进行递归</li>
<li>中间一刀两段 slowp.next = null;</li>
<li>对左侧进行递归</li>
<li>将左右两边merge并返回</li>
<li>merge就是普通的链表merge，定义一个头结点，一个while两个if，完美解决<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode sortList(ListNode head) &#123;</span><br><span class="line">        //快速处理特殊情况</span><br><span class="line">        <span class="keyword">if</span>(head == null || head.next == null)&#123;</span><br><span class="line">            <span class="built_in">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slowp = head;</span><br><span class="line">        ListNode fastp = head.next.next;</span><br><span class="line">        ListNode left=null,right=null;</span><br><span class="line">        //找到链表的中间结点</span><br><span class="line">        <span class="keyword">while</span>(fastp != null &amp;&amp; fastp.next != null)&#123;</span><br><span class="line">            slowp = slowp.next;</span><br><span class="line">            fastp = fastp.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        right = sortList(slowp.next);</span><br><span class="line">        slowp.next = null;</span><br><span class="line">        left = sortList(head);</span><br><span class="line">        <span class="built_in">return</span> merge(left,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static ListNode merge(ListNode left, ListNode right)&#123;</span><br><span class="line">        //头结点</span><br><span class="line">        ListNode tempHead = new ListNode();</span><br><span class="line">        ListNode p1=left,p2=right,p3=tempHead;</span><br><span class="line">        <span class="keyword">while</span>(p1!=null &amp;&amp; p2!=null)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.val&lt;=p2.val)&#123;</span><br><span class="line">                p3.next = p1;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p3.next = p2;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p3 = p3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1 != null)&#123;</span><br><span class="line">            p3.next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2 != null)&#123;</span><br><span class="line">            p3.next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> tempHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>#链表快速排序</p>
<ol>
<li>先排除特殊情况，再定义一个头结点，调用quickSort方法</li>
<li>quickSort方法接收head和end两种参数</li>
<li>先规定好basecase，包括head、head.next、head.next.next等于end的情况</li>
<li>然后创建一个临时头结点，用来暂管较小部分的链表</li>
<li>选择头结点后面的结点（第一个有效结点作为主元），用pivot指针指着</li>
<li>定义一个p指针作为主链扫描指针，p先指着主元</li>
<li>以p.next!=null作为循环条件（主元扫描指针下一个元素不等于空）。主元的下一个元素，如果比主元小，就接到临时链上，由临时链上的扫描指针指着</li>
<li>如果比主元大，那么p扫描指针就向前一步</li>
<li>小链接大链 tp.next = head.next</li>
<li>头结点归位 head.next=tmpHead.next</li>
<li>递归调用 head pivot; pivot end</li>
<li>返回head.next<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static ListNode sort(ListNode head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == null || head.next == null)&#123;</span><br><span class="line">            <span class="built_in">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = new ListNode();</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        //连表的前后弦</span><br><span class="line">        <span class="built_in">return</span> quickSort(newHead,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里的head是指头结点</span><br><span class="line">    //用一个临时的结点作为存储小的部分的链表头结点</span><br><span class="line">    static ListNode quickSort(ListNode head, ListNode end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==end||head.next==end||head.next.next==end)&#123;</span><br><span class="line">            <span class="built_in">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tmpHead = new ListNode();</span><br><span class="line">        ListNode pivot = head.next;</span><br><span class="line">        ListNode p = pivot;</span><br><span class="line">        ListNode tp = tmpHead;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=null)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.next.val&lt;pivot.val)&#123;</span><br><span class="line">                tp.next = p.next;</span><br><span class="line">                p.next = p.next.next;</span><br><span class="line">                tp = tp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //将小串和大串接起来</span><br><span class="line">        tp.next = head.next;</span><br><span class="line">        //头结点归位</span><br><span class="line">        head.next = tmpHead.next;</span><br><span class="line">        quickSort(head,pivot);</span><br><span class="line">        quickSort(pivot,end);</span><br><span class="line">        <span class="built_in">return</span> head.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>#ReorderList<br>前面几道题的综合</p>
<ol>
<li>快慢指针找中间节点</li>
<li>分成两个结点</li>
<li>翻转第二个链表</li>
<li>合并两个链表<br>ps:任何时候都要注意个数少时（0、1、2）的特殊情况，上来先讨论<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void reorderList(ListNode head) &#123;</span><br><span class="line">        //考虑特殊情况下,0，1，2个元素</span><br><span class="line">        <span class="keyword">if</span>(head==null||head.next==null||head.next.next==null)&#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode slowp=head,fastp=head.next.next;</span><br><span class="line">        ListNode tempHead=null;</span><br><span class="line">        <span class="keyword">while</span>(fastp!=null &amp;&amp; fastp.next!=null)&#123;</span><br><span class="line">            slowp = slowp.next;</span><br><span class="line">            fastp = fastp.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tempHead = slowp.next;</span><br><span class="line">        slowp.next = null;</span><br><span class="line"></span><br><span class="line">        ListNode prev = null,temp=null;</span><br><span class="line">        ListNode curr = tempHead;</span><br><span class="line">        <span class="keyword">while</span>(curr != null)&#123;</span><br><span class="line">            temp = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode fakeHead = new ListNode();</span><br><span class="line">        ListNode p1=head,p2=prev,p3=fakeHead;</span><br><span class="line">        <span class="keyword">while</span>(p1!=null &amp;&amp; p2!=null)&#123;</span><br><span class="line">            p3.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p3 = p3.next;</span><br><span class="line">            p3.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            p3 = p3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1 != null)&#123;</span><br><span class="line">            p3.next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2 != null)&#123;</span><br><span class="line">            p3.next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="检查链表是否有环"><a href="#检查链表是否有环" class="headerlink" title="检查链表是否有环"></a>检查链表是否有环</h1><h2 id="方法一：使用HashSet检查重复元素"><a href="#方法一：使用HashSet检查重复元素" class="headerlink" title="方法一：使用HashSet检查重复元素"></a>方法一：使用HashSet检查重复元素</h2><p>遍历链表，如果结点不在set中，则加入其中；如果结点在set中，则返回有环<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        Set&lt;ListNode&gt; <span class="built_in">set</span> = new HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head != null)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(head))&#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(head);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法二：快慢指针同时起跑"><a href="#方法二：快慢指针同时起跑" class="headerlink" title="方法二：快慢指针同时起跑"></a>方法二：快慢指针同时起跑</h2><h1 id="链表以k为分组进行反转"><a href="#链表以k为分组进行反转" class="headerlink" title="链表以k为分组进行反转"></a>链表以k为分组进行反转</h1><p>ps：注意java中的对象参数类似于指针，java没有引用</p>
<ol>
<li>设置四个指针tempHead、prev、curr、next</li>
<li>tempHead是整个链表的头结点指针，prev相当于是每个分组的头结点指针</li>
<li>curr指向每个分组的第一个结点，next指向curr结点之后的结点</li>
<li>首先获得链表的长度</li>
<li>设置两层for循环，第一层循环的上限分组数</li>
<li>内层循环是反转一个分组所需要的操作数，k=1时0，k=2时1，所以最多执行k-1次</li>
<li>具体操作是让next先指向curr之后的位置，curr指向next之后的结点防止断链，next插入到prev后面<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int length = 0;</span><br><span class="line">        //设置一个头结点</span><br><span class="line">        ListNode tempHead = new ListNode();</span><br><span class="line">        tempHead.next = head;</span><br><span class="line">        //设置每个分组的头结点指针</span><br><span class="line">        ListNode prev = tempHead;</span><br><span class="line">        //设置当前结点指针</span><br><span class="line">        ListNode curr = prev.next;</span><br><span class="line">        //设置后续指针</span><br><span class="line">        ListNode next = null;</span><br><span class="line">        //为了方便分组，需要知道数组的长度</span><br><span class="line">        <span class="keyword">while</span>(curr!=null)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //记得指针归位</span><br><span class="line">        curr = prev.next;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;length/k;i++)&#123;</span><br><span class="line">            //外层循环分组</span><br><span class="line">            <span class="keyword">for</span>(int j=0;j&lt;k-1;j++)&#123;</span><br><span class="line">                //内层规定操作次数</span><br><span class="line">                //在这个区域内做一个反转</span><br><span class="line">                next = curr.next;</span><br><span class="line">                curr.next = next.next;</span><br><span class="line">                next.next = prev.next;</span><br><span class="line">                prev.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> tempHead.next;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这也为普通的重排链表提供了新思路，设置一个头结点、并获取到链表长度，将第一个节点后面的节点不断的插入到头结点的后面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode tempHead = new ListNode();</span><br><span class="line">        tempHead.next = head;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        ListNode next = null;</span><br><span class="line">        int length = 0;</span><br><span class="line">        <span class="keyword">while</span>(curr!=null)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;length-1;i++)&#123;</span><br><span class="line">            next = curr.next;</span><br><span class="line">            curr.next = next.next;</span><br><span class="line">            next.next = tempHead.next;</span><br><span class="line">            tempHead.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> tempHead.next;</span><br></pre></td></tr></table></figure></p>
<h1 id="MergeKSortedList"><a href="#MergeKSortedList" class="headerlink" title="MergeKSortedList"></a>MergeKSortedList</h1><h2 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h2><ol>
<li>将输入链表的值都存储到一个数组中</li>
<li>对这个数组进行快排操作</li>
<li>将这个数组构造成链表<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class="line">        //将三个链表的数据都存到一个数组中</span><br><span class="line">        int[] arr = new int[getLength(lists[0])+getLength(lists[1])+getLength(lists[2])];</span><br><span class="line">        int i = 0;</span><br><span class="line">        <span class="keyword">for</span>(int j=0;j&lt;lists.length;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(lists[j]!=null)&#123;</span><br><span class="line">                arr[i] = lists[j].val;</span><br><span class="line">                lists[j] = lists[j].next;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //对数组进行排序</span><br><span class="line">        quickSort(arr,0,arr.length-1);</span><br><span class="line">        System.out.println(<span class="string">"数组结果"</span>);</span><br><span class="line">        <span class="keyword">for</span>(int a : arr)&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">        //将数组变成链表</span><br><span class="line">        <span class="built_in">return</span> createList(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取链表长度</span><br><span class="line">    static int getLength(ListNode list)&#123;</span><br><span class="line">        int length = 0;</span><br><span class="line">        <span class="keyword">while</span>(list != null)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            list = list.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //快速排序</span><br><span class="line">    static void quickSort(int[] data,int low,int high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">            int pivotIndex = partition(data,low,high);</span><br><span class="line">            quickSort(data,low,pivotIndex-1);</span><br><span class="line">            quickSort(data,pivotIndex+1,high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int partition(int[] data,int low,int high)&#123;</span><br><span class="line">        int pivot = data[low];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; data[high]&gt;=pivot)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            data[low] = data[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; data[low]&lt;=pivot)&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            data[high] = data[low];</span><br><span class="line">        &#125;</span><br><span class="line">        data[low] = pivot;</span><br><span class="line">        <span class="built_in">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static ListNode createList(int[] data)&#123;</span><br><span class="line">        ListNode head = new ListNode(data[data.length-1]);</span><br><span class="line">        <span class="keyword">for</span>(int i=data.length-2;i&gt;=0;i--)&#123;</span><br><span class="line">            ListNode temp = new ListNode(data[i],head);</span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/17/链表题/" data-id="ckblw37b9000oggwz6u8skfk4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-5-最长回文子串" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/17/5-最长回文子串/" class="article-date">
  <time datetime="2020-06-17T11:51:59.000Z" itemprop="datePublished">2020-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/5-最长回文子串/">5 最长回文子串</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#解法一：暴力法</p>
<ol>
<li>列举出所有可能的子串</li>
<li>专门写一个函数，检查子串和它的逆序是否相等</li>
<li>使用hashmap将最大的长度和字符串对应起来</li>
<li>反转字符串可以使用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new StringBuilder(str).reverse().toString()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>StringBuilder和StringBuffer很相似，StringBuffer线程安全；StringBuilder速度更快<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static String longestPalindrome(String s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        int maxlength=0;</span><br><span class="line">        HashMap&lt;Integer,String&gt; map = new HashMap();</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j=i+1;j&lt;s.length()+1;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(check(s.substring(i,j)))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-i&gt;maxlength)&#123;</span><br><span class="line">                        maxlength = j-i;</span><br><span class="line">                        map.put(maxlength,s.substring(i,j));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> map.get(maxlength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean check(String substring)&#123;</span><br><span class="line">        <span class="keyword">if</span>(substring.equals(new StringBuilder(substring).reverse().toString()))&#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>#动态规划法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/17/5-最长回文子串/" data-id="ckblw379k0000ggwzvmr8ctv1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Sort-algorithm-review" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/17/Sort-algorithm-review/" class="article-date">
  <time datetime="2020-06-17T03:38:09.000Z" itemprop="datePublished">2020-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/Sort-algorithm-review/">Sort algorithm review</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#快速排序</p>
<ol>
<li>在主要排序部分，使用递归的形式实现。参数是list、low、high，base case是low &lt; high</li>
<li>先对当前的序列进行一次划分partition，返回主元下标，然后在主元两端递归调用方法；</li>
<li>划分部分，先选择主元；</li>
<li>以一个大的while循环作为主要部分，限制条件是low &lt; high</li>
<li>在while循环内部，使用两个while分别表示从高位扫描和从低位扫描的两种情况</li>
<li>partition最终返回的是主元的索引</li>
<li>最坏情况是O(n^2)，发生在数组有序时；最好情况和一般情况都是O(nlogn)，最好情况发生在划分后主元两端元素相同时<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static int partition(int[] list, int low, int high)&#123;</span><br><span class="line">        int pivot = list[low];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; list[high]&gt;=pivot)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            list[low] = list[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; list[low]&lt;=pivot)&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            list[high] = list[low];</span><br><span class="line">        &#125;</span><br><span class="line">        list[low] = pivot;</span><br><span class="line">        <span class="built_in">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void quickSort(int[] list, int low, int high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">            int pivotIndex = partition(list,low,high);</span><br><span class="line">            quickSort(list,pivotIndex+1,high);</span><br><span class="line">            quickSort(list,low,pivotIndex-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>#归并排序</p>
<ol>
<li>主要部分采用递归分治策略，递归条件是low &lt; high，之后算出中点左右分别递归调用函数，最终用merge函数实现合并</li>
<li>merge函数中需要定义一个与输入数组等长的辅助数组；</li>
<li>定义三个指针分别指向数组前半段、数组后半段，辅助数组</li>
<li>使用三个while进行操作，按照出牌的方式。两边轮流打擂台，比大小，较小的先进入辅助数组</li>
<li>之所以使用三个while是因为还要考虑一边出完牌，另一边还没有出完的情况</li>
<li>辅助数组中的元素要重新赋值给原数组，注意赋值时的low、high界限<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static void merge(int[] current, int low, int mid, int high)&#123;</span><br><span class="line">        //合并连个数组（一个数组的前后两端，需要三个指针）</span><br><span class="line">        int[] targetTemp = new int[current.length];</span><br><span class="line">        int i=mid+1,j=low,k=low;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=high &amp;&amp; j&lt;=mid) &#123;</span><br><span class="line">            <span class="keyword">if</span>(current[i]&lt;=current[j])&#123;</span><br><span class="line">                targetTemp[k]=current[i];</span><br><span class="line">                k++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                targetTemp[k]=current[j];</span><br><span class="line">                k++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=high)&#123;</span><br><span class="line">            targetTemp[k]=current[i];</span><br><span class="line">            k++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=mid)&#123;</span><br><span class="line">            targetTemp[k]=current[j];</span><br><span class="line">            k++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int n=low;n&lt;=high;n++)&#123;</span><br><span class="line">            current[n] = targetTemp[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //low、high对应的是index</span><br><span class="line">    static void mergeSort(int[] current,int low, int high)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">            int mid = (low+high)/2;</span><br><span class="line">            mergeSort(current,low,mid);</span><br><span class="line">            mergeSort(current,mid+1,high);</span><br><span class="line">            merge(current,low,mid,high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>#堆排序</p>
<ol>
<li>主要分为两部分：总体部分、调整部分</li>
<li>总体部分接收一个list作为参数。首先从第一个非叶子节点开始，初建大顶堆；然后用一个for循环，先交换第一个和最后一个，然后再从第一个结点开始调整，范围不包括最后一个</li>
<li>调整部分接受三个参数：list、调整范围、调整结点编号</li>
<li>先将调整结点的值赋给临时变量</li>
<li>然后用一个while循环，限制条件是左子节点不越界</li>
<li>在while循环内先判断一下右子节点是否越界，在不越界且右子节点比左子节点大的情况下，指向右子节点</li>
<li>然后将当前指向的结点和临时变量的值进行比较，如果比临时变量大，则用子结点覆盖当前节点，并进一步指向子结点的左子节点</li>
<li>在while结束之后，将临时变量赋给它最终的位置处<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static void sort(int[] list)&#123;</span><br><span class="line">        //从第一个非叶子节点开始调整</span><br><span class="line">        int temp=0;</span><br><span class="line">        //初建大顶堆</span><br><span class="line">        <span class="keyword">for</span>(int i=list.length/2-1;i&gt;=0;i--)&#123;</span><br><span class="line">            //从第一个非叶子节点开始，调整范围是整个数组</span><br><span class="line">            heapAdjust(list,list.length,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i=list.length-1;i&gt;=1;i--)&#123;</span><br><span class="line">            //交换第一个和最后一个</span><br><span class="line">            temp = list[0];</span><br><span class="line">            list[0] = list[i];</span><br><span class="line">            list[i] = temp;</span><br><span class="line">            //从第一个开始，调整范围不包括最后一个</span><br><span class="line">            heapAdjust(list,i,0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //参数1是list，参数2是调整范围长度，参数3是调整结点</span><br><span class="line">    static void heapAdjust(int[] list, int len, int i)&#123;</span><br><span class="line">        //临时变量存储</span><br><span class="line">        int temp = list[i];</span><br><span class="line">        int index = 2*i+1;</span><br><span class="line">        //当左子节点结点没有超过调整范围</span><br><span class="line">        <span class="keyword">while</span>(index&lt;len)&#123;</span><br><span class="line">            //比较左右子节点</span><br><span class="line">            <span class="keyword">if</span>(index+1&lt;len &amp;&amp; list[index]&lt;list[index+1])</span><br><span class="line">                //如果右子节点没有超过范围，且右子节点比较大,则指向右子节点</span><br><span class="line">                index++;</span><br><span class="line">            <span class="keyword">if</span>(list[index]&gt;temp)&#123;</span><br><span class="line">                list[i] = list[index];</span><br><span class="line">                i = index;</span><br><span class="line">                index = 2*index+1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //将临时存储的变量交给最终确定的位置</span><br><span class="line">        list[i] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注：快速排序是不稳定的，归并排序是稳定的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/17/Sort-algorithm-review/" data-id="ckblw37ad000bggwzswposu46" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-LongestNonRepeat" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/17/LongestNonRepeat/" class="article-date">
  <time datetime="2020-06-17T01:11:44.000Z" itemprop="datePublished">2020-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/LongestNonRepeat/">LongestNonRepeat</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Leetcode problem-3</p>
<h1 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h1><ol>
<li>利用两个for循环列举出string中所有可能的substring的情况；</li>
<li>再编写一个接收string参数的函数，这个函数的作用是检查string中是否有重复的字母；<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static class Solution &#123;</span><br><span class="line">        public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">            //考虑从一个字母到所有字母都上的情况</span><br><span class="line">            int maxlength=0;</span><br><span class="line">            //String maxstr = null;</span><br><span class="line">            <span class="keyword">for</span>(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(int j=i+1;j&lt;s.length()+1;j++)&#123;</span><br><span class="line">                    String temp = s.substring(i,j);</span><br><span class="line">                    <span class="keyword">if</span>(check(temp))&#123;</span><br><span class="line">                        //没有重复字符</span><br><span class="line">                        <span class="keyword">if</span>(temp.length()&gt;maxlength)&#123;</span><br><span class="line">                            maxlength = temp.length();</span><br><span class="line">                            //maxstr = temp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        //有重复字符</span><br><span class="line">                        <span class="built_in">continue</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> maxlength;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean check(String substring)&#123;</span><br><span class="line">            Set&lt;Character&gt; <span class="built_in">set</span> = new HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(int i=0;i&lt;substring.length();i++)&#123;</span><br><span class="line">                Character ch = substring.charAt(i);</span><br><span class="line">                <span class="keyword">if</span>(set.contains(ch))</span><br><span class="line">                    //说明有重复</span><br><span class="line">                    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">                //在不包括的情况下要加进去</span><br><span class="line">                set.add(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>总结：<br>在检查是否有重复字母时，使用到了HashSet；</p>
<ol>
<li>HashSet基于HashMap，组合了Hash在迭代时不能保证顺序；</li>
<li>具有add、remove、contains、size操作，时间复杂度都是O(1)级别</li>
<li>线程不安全</li>
<li>HashSet是为了快速查找而设计的set，set是一种特殊的collection,不保存重复的元素</li>
<li>Map适合存储键值对数据，常用操作get、put；Set检索能力低下，但是删除和插入效率高，常用操作add、remove、contains；List与数组类似，可以动态增长，插入删除效率低。</li>
</ol>
<h1 id="解法二：Sliding-windows"><a href="#解法二：Sliding-windows" class="headerlink" title="解法二：Sliding windows"></a>解法二：Sliding windows</h1><p>（本题能使用滑动窗口，原因是因为：要求连续、且连续部分有内部的限制）</p>
<ol>
<li>形成一个字符串的滑动窗口</li>
<li>设定坐标i、j，当新加入的成员满足要求时，增长j</li>
<li>当新加入的成员不满足要求时，增加i，进行缩减检查<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">            int j = 0;</span><br><span class="line">            int maxlength = 0;</span><br><span class="line">            Set&lt;Character&gt; <span class="built_in">set</span> = new HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(i&lt;s.length() &amp;&amp; j&lt;s.length())&#123;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(s.charAt(j)))&#123;</span><br><span class="line">                    //如果集合中已经包含了新加进来的字符，则去掉，然后更改索引</span><br><span class="line">                    set.remove(s.charAt(i));</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    //如果不包含最左侧的字符</span><br><span class="line">                    set.add(s.charAt(j));</span><br><span class="line">                    j++;</span><br><span class="line">                    maxlength = Math.max(maxlength,j-i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> maxlength;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：</p>
<ol>
<li>HashSet和HashMap的参数都要求是对象int对应Integer，char对应Character</li>
<li>String获取指定索引字符的方式：str.charAt(i)</li>
<li>快速比大小：Math.max(a,b)</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/17/LongestNonRepeat/" data-id="ckblw37a20006ggwzmm3xuho5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Add-two-numbers" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/Add-two-numbers/" class="article-date">
  <time datetime="2020-06-14T12:27:08.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/Add-two-numbers/">Add_two_numbers</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Add-Two-Numbers"><a href="#Add-Two-Numbers" class="headerlink" title="Add Two Numbers"></a>Add Two Numbers</h1><h1 id="基本数学解法，要考虑到多种意外情况"><a href="#基本数学解法，要考虑到多种意外情况" class="headerlink" title="基本数学解法，要考虑到多种意外情况"></a>基本数学解法，要考虑到多种意外情况</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     <span class="function"><span class="title">ListNode</span></span>() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">import static java.lang.Integer.max;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        int count1 = 0;</span><br><span class="line">            int count2 = 0;</span><br><span class="line">            ListNode temp;</span><br><span class="line">            ListNode list1 = l1;</span><br><span class="line">            ListNode list2 = l2;</span><br><span class="line">            temp = l1;</span><br><span class="line">            <span class="keyword">while</span>(temp!=null)&#123;</span><br><span class="line">                count1++;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = l2;</span><br><span class="line">            <span class="keyword">while</span>(temp!= null)&#123;</span><br><span class="line">                count2++;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            //ListNode result = new</span><br><span class="line">            int size = max(count1,count2)+1;</span><br><span class="line">            int[] result = new int[size];</span><br><span class="line">            <span class="keyword">for</span>(int i=0;list1!=null||list2!=null;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(list1==null||list2==null)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(list1==null)&#123;</span><br><span class="line">                        result[i]=result[i]+list2.val;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        result[i]=result[i]+list1.val;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    result[i]=result[i]+list1.val+list2.val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(result[i]&gt;=10)&#123;</span><br><span class="line">                    result[i+1]=result[i]/10;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    result[i+1]=0;</span><br><span class="line">                &#125;</span><br><span class="line">                result[i]=result[i]%10;</span><br><span class="line">                <span class="keyword">if</span>(list1 == null)&#123;</span><br><span class="line">                    list2 = list2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(list2 == null)&#123;</span><br><span class="line">                    list1 = list1.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    list1 = list1.next;</span><br><span class="line">                    list2 = list2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ListNode first = null;</span><br><span class="line">            ListNode second = null;</span><br><span class="line">            <span class="keyword">if</span>(result[size-1]!=0)&#123;</span><br><span class="line">                first = new ListNode(result[size-1]);</span><br><span class="line">                <span class="keyword">for</span>(int i=size-2;i&gt;=0;i--)&#123;</span><br><span class="line">                    second = new ListNode(result[i],first);</span><br><span class="line">                    first = second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                first = new ListNode(result[size-2]);</span><br><span class="line">                <span class="keyword">for</span>(int i=size-3;i&gt;=0;i--)&#123;</span><br><span class="line">                    second = new ListNode(result[i],first);</span><br><span class="line">                    first = second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结知识点</p>
<ol>
<li><p>Java中的链表数据结构<br>使用类来表示链表结点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    <span class="function"><span class="title">ListNode</span></span>()&#123;&#125;;</span><br><span class="line">    ListNode(int val)&#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode(int val,ListNode next)&#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对链表进行遍历的方式<br>使用一个temp指针指向一个结点，然后temp=temp.next这样的去遍历</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void displayList(ListNode list)&#123;</span><br><span class="line">        ListNode temp = list;</span><br><span class="line">        <span class="keyword">if</span>(temp == null)&#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(temp!=null)&#123;</span><br><span class="line">            System.out.print(temp.val+<span class="string">" "</span>);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/Add-two-numbers/" data-id="ckblw379r0001ggwzwxyqb84p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Two-Sum" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/13/Two-Sum/" class="article-date">
  <time datetime="2020-06-13T07:27:57.000Z" itemprop="datePublished">2020-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/13/Two-Sum/">Two Sum</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h1><h2 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;nums.length-1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j=i+1;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                    <span class="built_in">return</span> new int[] &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> new int[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结知识点：</p>
<ol>
<li><p>java查看数组长度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums.length</span><br></pre></td></tr></table></figure>
</li>
<li><p>java创建匿名数组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new int[]&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="解法二：HashMap"><a href="#解法二：HashMap" class="headerlink" title="解法二：HashMap"></a>解法二：HashMap</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(target-nums[i])!=null)&#123;</span><br><span class="line">                <span class="built_in">return</span> new int[]&#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> new int[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法大意：<br>找到自己的另一半<br>如果另一半还没有出现<br>就先领着自己的号牌，去hashmap中去等待<br>当另一半出现了，返回两个人的号牌</p>
<p>总结知识点：</p>
<ol>
<li>创建HashMap<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;K,V&gt; map = new HashMap&lt;K,V&gt;();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在Java中，K、V都需要是对象类型，不可以是基础数据类型<br>int可以用Integer代替</p>
<ol start="2">
<li>取元素<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.get(K);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果K值对应的V不存在，则返回的是null</p>
<ol start="3">
<li>放元素<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(K,V);</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/13/Two-Sum/" data-id="ckblw37ah000dggwzo86xnjvb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/19/java-foundamental/">java foundamental</a>
          </li>
        
          <li>
            <a href="/2020/06/18/动态规划/">动态规划</a>
          </li>
        
          <li>
            <a href="/2020/06/18/二叉树/">二叉树</a>
          </li>
        
          <li>
            <a href="/2020/06/18/全排列/">全排列</a>
          </li>
        
          <li>
            <a href="/2020/06/17/链表题/">链表题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>