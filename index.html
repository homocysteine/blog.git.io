<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Homocysteine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Homocysteine">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Homocysteine">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Homocysteine">
  
    <link rel="alternate" href="/atom.xml" title="Homocysteine" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Homocysteine</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-每日一题" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/27/每日一题/" class="article-date">
  <time datetime="2020-06-27T05:38:03.000Z" itemprop="datePublished">2020-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/27/每日一题/">每日一题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#最小未出现的正整数</p>
<ol>
<li>创建一个和当前数组相同的数组</li>
<li>使用for+while+swap实现一个换座位的算法</li>
<li>第一个人与它应该做的座位的人交换位置，然后重复操作</li>
<li>对之后的每个座位执行同样的操作</li>
<li>如果前面几个人刚好是前面的几个正整数的话，应该正好“对号入座”。即nums[i]应该在nums[nums[i]-1]这个位置上</li>
<li>如果不是，则有人的值与索引值不一致<br>巧妙利用了索引与正整数的对应关系<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public int firstMissingPositive(int[] nums) &#123;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]&gt;0 &amp;&amp; nums[i]&lt;=nums.length &amp;&amp; nums[i] != nums[nums[i]-1])&#123;</span><br><span class="line">                //交换nums[i]和nums[nums[i-1]]</span><br><span class="line">                swap(nums,i,nums[i]-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=i+1)&#123;</span><br><span class="line">                <span class="built_in">return</span> i+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //此时说明数组中正好是正整数的前几位</span><br><span class="line">        <span class="built_in">return</span> nums.length+1;</span><br><span class="line">    &#125;</span><br><span class="line">    void swap(int[] nums,int i,int j)&#123;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/27/每日一题/" data-id="ckbxbfwn8000t6cwzu5nxdo5s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android开发屏幕显示" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/26/Android开发屏幕显示/" class="article-date">
  <time datetime="2020-06-26T12:08:40.000Z" itemprop="datePublished">2020-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/26/Android开发屏幕显示/">Android开发屏幕显示</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#像素<br>常用的像素单位：px、dp、sp</p>
<ol>
<li>px与物理设备的像素密度有关，同样的屏幕尺寸，像素密度越高，屏幕越清晰</li>
<li>dp与物理设备无关，只与屏幕有关。当density=1时，dp与px是1比1关系</li>
<li>sp与dp类似，专门用于字体大小。sp设置的字体大小可以随系统调整</li>
<li>在xml文件中使用的像素单位是dp、sp</li>
<li>有的函数的参数使用的单位是px，可以用density变量实现px和dp的互换</li>
<li>通过DisplayMetrics对象可以获得屏幕的宽度和高度，以及像素密度</li>
</ol>
<p>#颜色</p>
<ol>
<li>可以使用6位16进制数或者8位16进制数（带透明度）两种方式。代码中0x开头，xml文件中#开头。值越高越亮，值越低越暗。</li>
<li>在Colors.xml中定义颜色，代码中R.color.引用；xml文件使用@color/引用</li>
<li>FF的alpha值表示完全不透明</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/26/Android开发屏幕显示/" data-id="ckbxbfwlw00026cwzrob8m1d7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-树" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/26/树/" class="article-date">
  <time datetime="2020-06-26T01:54:28.000Z" itemprop="datePublished">2020-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/26/树/">树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#树的递归定义</p>
<ol>
<li>有且只有一个结点没有父结点</li>
<li>除根以外，其它结点有且仅有一个父结点</li>
<li>每个结点都构成一个以它为根的子树</li>
</ol>
<p>ps:前中后指的是根的位置<br>前中后搜索都属于深度优先搜索</p>
<p>#112判断路经总和</p>
<ol>
<li>采用前序遍历的方式</li>
<li>前序遍历的操作部分改成判断叶子节点是否等于最后相减的值</li>
<li>参数除了树节点外还有一个sum值，雁过拔毛法</li>
<li>在使用树节点遍历时，判断结点为空的处理是必须要有的</li>
<li>Java中虽然没有引用，但是可以用属性（全局变量）来实现相同的效果<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    boolean ans = <span class="literal">false</span>;</span><br><span class="line">    public boolean hasPathSum(TreeNode root, int sum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preorder(root,sum);</span><br><span class="line">        <span class="built_in">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void preorder(TreeNode root,int sum)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==null &amp;&amp; root.right==null &amp;&amp; root.val == sum)&#123;</span><br><span class="line">            ans = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preorder(root.left,sum-root.val);</span><br><span class="line">        preorder(root.right,sum-root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>#113 判断路经总和升级版<br>需要返回的不是true或者false，而是返回一个结果的集合（使用List实现）</p>
<ol>
<li>先入栈，加值</li>
<li><p>叶子节点判断条件，满足则加入最终的结果集，注意要创建一个副本去加入，否则会是空集</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(path);</span><br></pre></td></tr></table></figure>
</li>
<li><p>再出栈，减值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int currSum = 0;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">            //存储结果集</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">            //存储单一结果</span><br><span class="line">            List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">                <span class="built_in">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            preorder(root,sum,path,res);</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void preorder(TreeNode root,int sum,List&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currSum += root.val;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left==null &amp;&amp; root.right==null &amp;&amp; currSum == sum )&#123;</span><br><span class="line">            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(path);</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        preorder(root.left,sum,path,res);</span><br><span class="line">        preorder(root.right,sum,path,res);</span><br><span class="line">        </span><br><span class="line">        currSum -= root.val;</span><br><span class="line">        path.remove(path.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>ps:ArrayList的部分操作,这几个也是collections体系种类库的共有操作</p>
<ol>
<li>add从后向前加入</li>
<li>get得到指定索引元素</li>
<li>set替换指定索引元素</li>
<li>remove可以按元素删除，也可以按索引删除</li>
</ol>
<p>#树的最近公共祖先</p>
<ol>
<li>找到从根到两个结点的两条路径</li>
<li>将两条路径的结点存储到List中</li>
<li>从后向前比较第一个相同的结点</li>
<li>在深度优先搜索的基础上，前序部分操作为入栈，比较返回；后序部分为出栈</li>
<li>深度搜索基本框架：判断空树-&gt;前序操作（入栈）-&gt;满足条件-&gt;递归调用-&gt;后续操作（出栈）</li>
<li>new ArrayList&lt;&gt;(res)可以创建一个结果的副本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;TreeNode&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; res;</span><br><span class="line">    boolean isFinished;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">        preorder(root,p);</span><br><span class="line">        isFinished = <span class="literal">false</span>;</span><br><span class="line">        List&lt;TreeNode&gt; list1 = new ArrayList&lt;&gt;(res);</span><br><span class="line">        preorder(root,q);</span><br><span class="line">        List&lt;TreeNode&gt; list2 = new ArrayList&lt;&gt;(res);</span><br><span class="line">        <span class="keyword">for</span>(int i = Math.min(list1.size(),list2.size())-1;i&gt;=0;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.get(i) == list2.get(i))&#123;</span><br><span class="line">                <span class="built_in">return</span> list1.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> null;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void preorder(TreeNode root,TreeNode search)&#123;</span><br><span class="line">        //空树判断+结束条件</span><br><span class="line">        <span class="keyword">if</span>(root == null||isFinished == <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        //前序操作</span><br><span class="line">        path.add(root);</span><br><span class="line">        <span class="keyword">if</span>(root == search)&#123;</span><br><span class="line">            isFinished = <span class="literal">true</span>;</span><br><span class="line">            res = new ArrayList&lt;&gt;(path);</span><br><span class="line">        &#125;</span><br><span class="line">        //递归左右子树</span><br><span class="line">        preorder(root.left,search);</span><br><span class="line">        preorder(root.right,search);</span><br><span class="line">        //后续操作</span><br><span class="line">        path.remove(path.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/26/树/" data-id="ckbxbfwna000v6cwze9jrp6b8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-abstract-class-and-interface" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/25/abstract-class-and-interface/" class="article-date">
  <time datetime="2020-06-25T07:00:35.000Z" itemprop="datePublished">2020-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/25/abstract-class-and-interface/">abstract class and interface</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#抽象方法<br>使用abstract关键字修饰，只有声明，没有具体实现；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract void run();</span><br></pre></td></tr></table></figure></p>
<p>抽象方法必须为public或者protected</p>
<p>#抽象类</p>
<ol>
<li>一个类含有抽象方法，则为抽象类，需要用abstarct修饰class</li>
<li>抽象类不能创建对象</li>
<li>一个类继承了抽象类，则必须实现抽象方法，否则这个子类也将变成抽象类</li>
</ol>
<p>#接口<br>在软件工程中，接口泛指提供给别人调用的方法或函数</p>
<ol>
<li>Java接口中的变量默认为public static final变量</li>
<li>方法默认是public abstract</li>
<li>非抽象类实现某个接口，【就必须实现该接口中的所有方法】</li>
</ol>
<p>抽象类是对事物的抽象，接口是对行为的抽象<br>飞机、鸟、飞</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/25/abstract-class-and-interface/" data-id="ckbxbfwmq000h6cwzphqqjhan" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-singleton" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/25/singleton/" class="article-date">
  <time datetime="2020-06-25T03:45:03.000Z" itemprop="datePublished">2020-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/25/singleton/">singleton</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#要点</p>
<ol>
<li>某个类只能有一个实例<br>实现：构造函数私有化</li>
<li>类必须自行创建实例<br>实现：含有一个类的静态变量来保存这个唯一实例</li>
</ol>
<p>最简单的一种方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    public static final singleton = new Singleton();</span><br><span class="line">    private <span class="function"><span class="title">Singleton</span></span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/25/singleton/" data-id="ckbxbfwn0000o6cwzq2to30lp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Internal-class" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/25/Internal-class/" class="article-date">
  <time datetime="2020-06-25T02:11:12.000Z" itemprop="datePublished">2020-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/25/Internal-class/">Internal-class</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#成员内部类</p>
<ol>
<li>直接定义在另一个类中的类</li>
<li>内部类可以使用外部类的所有成员</li>
<li><p>当内部类成员和外部类成员同名时，内部类默认使用的是内部成员。如果要使用外部成员</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.this.成员</span><br></pre></td></tr></table></figure>
</li>
<li><p>外部类如果想访问内部成员，需要创建一个内部类对象，再通过这个对象引用内部类的成员</p>
</li>
<li><p>内部类对象是依附于外部类对象存在的，创建内部类对象的方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outter otter = new Outter();</span><br><span class="line">Outter.Inner inner = outter.new Inner();</span><br></pre></td></tr></table></figure>
</li>
<li><p>外部类访问权限：<br>public(可以被本项目的其它类使用，类名必须要和文件名相同)；<br>default（只能被同一个包中的类访问）</p>
</li>
<li><p>内部类访问权限：<br>public:任何地方都可以被访问；<br>protected:同一个包下或者外部类的子类可以访问<br>default:同一个包下的类可以访问<br>private：只能在所在外部类中被访问</p>
</li>
</ol>
<p>#局部内部类<br>定义在一个方法或者作用域中的类，访问仅限于方法内或者作用域内<br>不能有修饰符，像一个局部变量一样</p>
<p>#匿名内部类<br>经典：Android设置按钮监听器<br>创建匿名内部类时能够实现父类或者接口中的方法<br>匿名内部类也无法修饰<br>匿名内部类没有构造器，编译器自动起名</p>
<p>#静态内部类<br>不依赖于外部类，类似于静态成员<br>不能使用外部类的非静态成员<br>创建静态内部类对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outter.Inner inner = new Outter.Inner();</span><br></pre></td></tr></table></figure></p>
<p>内部类会被单独编译成一个字节码文件outter$inner.class<br>内部类方便了类的组合<br>内部类使用外部控件，加final修饰，目的是为了防止button被修改</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/25/Internal-class/" data-id="ckbxbfwmb00066cwz93wq6533" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-memory-model" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/24/java-memory-model/" class="article-date">
  <time datetime="2020-06-24T14:18:20.000Z" itemprop="datePublished">2020-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/24/java-memory-model/">java-memory-model</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#JVM三大性能调优参数-Xms -Xmx -Xss的含义<br><img src="/2020/06/24/java-memory-model/three-parameter.png" alt=""><br>-Xss规定了每个线程虚拟机栈的大小（stack）<br>-Xms规定了堆的初始容量<br>-Xmx规定了堆的最大容量（一般和-Xms设置成一样的，防止内存抖动）</p>
<p>#内存分配的三种策略：</p>
<ol>
<li>静态存储：在编译时确定每个数据目标运行时的内存需求（不能有可变数据结构、嵌套、递归）</li>
<li>栈式存储：编译时未知，运行时模块入口前确定</li>
<li>对是存储：编译时未知，运行时模块入口时也未知，动态分配内存</li>
</ol>
<p>#Java内存模型中堆和栈的区别<br>数组、对象实例都保存在堆中，在栈中定义变量保存堆中实例的首地址（引用变量）</p>
<ol>
<li>所以，引用变量会自动释放，而实例本身不会，实例对象本身存储在堆中，等待GC处理</li>
<li>所以当我们用String str = new String(“123”)创建对象时，会在栈中创建一个引用对象（地址），在对中创建一个实例对象。<br>new出来的在堆里</li>
<li>区别一：栈自动释放，堆GC管理</li>
<li>区别二：栈一般比堆要小</li>
<li>区别三：堆活动量较大，GC的非实时性，产生的碎片量较多</li>
<li>区别四：栈支持静态和动态，对仅支持动态（是堆的优点，更灵活）</li>
<li>区别五：栈的效率要比堆要搞</li>
</ol>
<p>#equals VS ==</p>
<ol>
<li>equals比较的是两个对象实例在内存中的内容</li>
<li>==比较的则是两个引用变量的值，即实例变量在堆中的首地址</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/24/java-memory-model/" data-id="ckbxbfwmt000k6cwzyl8hlls8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/23/设计模式/" class="article-date">
  <time datetime="2020-06-23T02:32:22.000Z" itemprop="datePublished">2020-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/23/设计模式/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#MVP模式<br>M-&gt;Model;V-&gt;View;P-&gt;Presenter<br>MVP从经典的MVC演变而来，与MVC类似Controller/Presenter负责逻辑的处理，Model负责提供数据，View负责显示<br>M数据处理（网络操作、数据库操作），V视图层显示，C交互处理<br>MVC中view会直接从Model中读取数据，而不是Controller<br>MVP中View不会直接使用Model，它们之间的通信是使用Presenter进行的</p>
<p>MVC优点：</p>
<ol>
<li>低耦合：降低了M和V的关联程度</li>
<li>将业务逻辑和界面分离，增强了程序的可维护性和可扩展性。比如待修改界面时，只需要更改V层；当需要新的数据需求时，只需要增加新的接口。</li>
<li>职责划分比较明确<br>MVC缺点：</li>
<li>MVC适用于逻辑处理复杂、需要模块化设计的大项目；小项目中使用MVC可能会导致程序过度设计，代码臃肿。</li>
<li>Activity中有很多关于视图UI的代码，所以在Activity中并不是单纯的C，还包括V的部分</li>
<li>View和Model还是互相耦合</li>
</ol>
<p>MVP模式是MVC模式在Android上的一种变体<br>MVC中Activity还是承担了M和C这两个层的工作，耦合度还是有点高，所以将Activity中的view和controller抽离出来，变成View和Presenter，这就是MVP模式</p>
<p>MVC模式中Activity的耦合度还是太高，业务逻辑与显示逻辑都写在Activity中，容易增城Activity臃肿。<br>而且写在Activity中的代码意味着不能被复用了</p>
<p>在MVP架构中，</p>
<ol>
<li>Model还是那个Model，Activity的UI逻辑层被抽象成View接口，业务逻辑层被抽象成Presenter接口。</li>
<li>Model和View之间也不能直接的进行交互</li>
<li>使代码更加简洁，进一步降低耦合，可以进行逻辑代码的复用</li>
<li>具体实现，在Activity中主要编写UI逻辑，业务逻辑写在一个接口中，然后去实现这个接口</li>
</ol>
<p>##MVVM模式<br>MVVM将MVC的Controller改进成ViewModel<br>在MVVM框架下，View和Model是不能直接通信的<br>ViewModel能够监听两端的变化，“实现数据的双向绑定”</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/23/设计模式/" data-id="ckbxbfwna000u6cwzopgnza51" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-foundamental" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/19/java-foundamental/" class="article-date">
  <time datetime="2020-06-19T03:46:03.000Z" itemprop="datePublished">2020-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/19/java-foundamental/">java foundamental</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java参数传递"><a href="#Java参数传递" class="headerlink" title="Java参数传递"></a>Java参数传递</h1><ol>
<li>基础数据类型是值传递</li>
<li>对象类型，实参和形参指向同一片内存，但是如果更改形参指向，不会影响实参</li>
<li>指针和引用还是有区别的，指针无法改变指向</li>
</ol>
<h1 id="Java继承"><a href="#Java继承" class="headerlink" title="Java继承"></a>Java继承</h1><ol>
<li>子类可以继承父类的 所有 属性和方法，还可以重写父类的方法，但是私有的是不能调用的</li>
<li>Object类是层次结构的根，java所有类都继承自这个类</li>
<li>构造子类对象前，要先构造父类对象，用super关键字实现</li>
<li>子类带参要先调父类带参</li>
<li>子类咔嚓一下就可以转换成父类，这是安全的，转换成谁，谁在左边</li>
<li>父类转换成子类时，需要用（）来实现强制转换</li>
<li>接口只有静态常量和抽象方法，十分抽象的类</li>
<li>定义接口是帮助子类进行扩展</li>
<li>Java只允许单继承，降低复杂性，但是可以实现多个接口；C++允许多继承</li>
</ol>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ol>
<li>static修饰类，只能修饰内部类</li>
<li>static修饰的方法可以通过类名来直接调用</li>
<li>static修饰的变量属于类，可以通过类名直接调用</li>
<li>类初始化顺序：先父类，后子类；先静态和非静态</li>
<li>父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数</li>
<li>java的对象放在堆区，线程共享；其它放在栈区，每个线程有一个</li>
<li>类和静态区存放在静态区，线程共享</li>
<li>静态随类，非静态随对象，所以静态方法中无法使用this、super</li>
<li>静态变量被所有类实例共享</li>
</ol>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><ol>
<li>final修饰类，则这个类不能被继承</li>
<li>final修饰方法，则这个方法不能被重写</li>
<li>final修饰基础类型变量，必须初始化，且只能初始化一次</li>
<li>final修饰对象类型变量，地址不能变</li>
</ol>
<h1 id="java编程知识积累"><a href="#java编程知识积累" class="headerlink" title="java编程知识积累"></a>java编程知识积累</h1><ol>
<li>java数组为null和空数组是不一样的概念。null表示这个对象引用是一个空引用；空数组表示是一个真正的对象，只不过元素数量为0</li>
</ol>
<h1 id="java异常"><a href="#java异常" class="headerlink" title="java异常"></a>java异常</h1><h2 id="java异常体系主要回答的三个问题"><a href="#java异常体系主要回答的三个问题" class="headerlink" title="java异常体系主要回答的三个问题"></a>java异常体系主要回答的三个问题</h2><p>what:异常类型回答了什么被抛出<br>where:异常堆栈跟踪回答了在哪里被抛出<br>why:异常信息回答了为什么会被抛出</p>
<h2 id="java的异常体系"><a href="#java的异常体系" class="headerlink" title="java的异常体系"></a>java的异常体系</h2><p><img src="/2020/06/19/java-foundamental/java_Exception.png" alt=""></p>
<ol>
<li>java异常的顶层父类是Throwable类，Throwable继承自Object类</li>
<li>Error:(JVM负责)程序无法处理的系统错误，编译器不做检查，遇到建议直接让程序终止 e.g. 系统崩溃、虚拟机错误、内存不足、方法调用栈溢出</li>
<li>Exception:程序可以处理的异常，捕获后可能修复，遇到应该尽可能去处理</li>
<li>Exception又可以分为runtimeException和非runtimeException</li>
<li>RuntimeException（程序负责）表示不可预知的，编译器不校验，程序应当进行避免 e.g.数组下标越界（outofIndex）、访问控制针(NullPointerException)</li>
<li>非runtimeException，（编译器负责）可以预知的错误，编译器校验的异常，不处理，程序不能被编译通过 I/OException、SQLException、ClassNotFound、EOFException<br>ps:java不能一个继承多个，但是可以一个被多个继承</li>
<li>尽量细化异常，不要泛化异常，因为一场本身就是为了方便定位问题的<h2 id="java常见Error和异常"><a href="#java常见Error和异常" class="headerlink" title="java常见Error和异常"></a>java常见Error和异常</h2></li>
<li>runtimeException<br>NullPointerException:在试图使用的对象是null<br>ClassCastException:不兼容类型之间的转换异常<br>IllegalArgumentException:传递非法参数的异常<br>IndexOutOfBoundsException:下标越界异常<br>NumberFormatException:将String转化成num，但是String确实不满足格式要求<br>ArithmeticException:除0错误</li>
<li>非runtimeException<br>ClassNotFoundException<br>I/OException</li>
<li>Error<br>NoClassDefFoundError:找不到class的定义，没有引入jar包<br>StackOverflowError:深递归导致方法调用栈被耗尽<br>OutOfMemoryError:内存溢出异常<br>##Java的异常处理机制</li>
<li>抛出异常<br>创建异常对象，交由运行时系统处理</li>
<li>捕获异常<br>寻找合适的异常处理器进行处理，如果没有找到，则终止程序<br>##Java异常处理流程</li>
<li>在出现异常时，在堆上创建异常对象</li>
<li>当异常出现时，当前的执行路径将会被终止（不会执行try块中后续的逻辑代码）</li>
<li>然后会抛出异常对象的引用</li>
<li>抛出的异常会被catch捕获，子类在前面就是子类子类捕获</li>
<li>catch中的return之前，会先执行finally子句中的语句，如果finally子句中出现了return，则不会再回到catch中执行那个return了</li>
<li>异常至多被一个catch匹配到，且匹配按照先后顺序进行匹配<br>##Java异常处理原则<br>具体明确、提早抛出、延迟捕获（让掌握更多信息的作用域去处理异常）<br>try-catch需要创建异常对象实例，保存栈快照，开销较大。所以尽量用try包裹一场出现的代码段<br>##Java throws和try-catch的区别</li>
<li>throws是向上抛出，将异常交给方法的调用方来处理异常</li>
<li>try-catch是捕获异常，自己处理异常<h2 id="ClassNotFoundException-VS-NotClassDefFundError"><a href="#ClassNotFoundException-VS-NotClassDefFundError" class="headerlink" title="ClassNotFoundException VS NotClassDefFundError"></a>ClassNotFoundException VS NotClassDefFundError</h2></li>
<li>ClassNotFound是因为在加载类时，找不到定义的class代码段，没有在内存中生成对应的类对象</li>
<li>NotClassDefFoundError时Error，编译能够通过，但是new对象时找不到类的定义而出错。可能原因：找不到class文件、class文件在不同的域中（在当前的java path下不可用，java path是我们配置环境变量时看到的那个东西）</li>
</ol>
<p>#Java底层</p>
<p>##平台无关性</p>
<ol>
<li>一次编译，到处运行，可以使用javac指令将java代码编译成.class字节码，让后用java指令运行程序</li>
<li>不同平台的JVM会解析字节码，将其转化成不同平台上的指令</li>
<li>引入字节码：防止每一次词法、语法、语义的检查工作，多次执行不需要做重复工作，提高性能</li>
<li>引入字节码还可以兼容别的语言，例如Ruby，也是可以编译成字节码，然后在JVM中执行</li>
</ol>
<p>##Java虚拟机</p>
<ol>
<li>屏蔽底层的不同，让程序员可以专注写java代码</li>
<li>JVM是内存中的虚拟机，JVM的存储就是内存<br><img src="/2020/06/19/java-foundamental/jvm.png" alt=""></li>
<li>JVM大致可以分为4个部分，class Loader、Runtime Data Area、Execution Engine、Native Interface</li>
<li>ClassLoader的作用是将编译好的class文件加载到内存，加载时依据特定的文件格式</li>
<li>Execution起到解释器的作用，解析class文件中的字节码，并提交给操作系统去执行</li>
<li>Native Interface融合不同开发语言的原生库来提供给Java使用，避免重复造轮子、提高执行效率<br>ps:Java在大多数情况下执行效率没有原生的C高，forName函数就是通过字符串来找到指定的类，调用了native接口</li>
<li>Runtime Data Area:JVM内存模型</li>
</ol>
<p>##Java反射</p>
<ol>
<li>动态获取信息、动态调用对象方法</li>
<li>在运行状态中，对于任意一个类，能够知道这个类的所有属性和方法；对于任意一个对象，能够知道调用这个对象中的任意属性和方法</li>
<li>java反射就是将java中的各种函数映射成对象：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//先用forName获取到class对象</span><br><span class="line">Class rc = Class.forName(<span class="string">"..."</span>);</span><br><span class="line">rc.getName();</span><br><span class="line">Method myMethod = rc.getMethod();</span><br><span class="line">Field myField = rc.getDeclaredField();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>##类从编译到执行的过程</p>
<ol>
<li>编译器：编译器将Student.java编译成Student.class字节码</li>
<li>ClassLoader:ClassLoader将字节码转换为JVM中的Class<student>对象</student></li>
<li>JVM:JVM利用Class<student>对象实例化Student对象</student></li>
</ol>
<p>##ClassLoader</p>
<ol>
<li>ClassLoader是一个抽象类，比较重要的方法是loadClass</li>
<li>loadClass接收字符串参数，返回class实例；如果找不到类，就向上抛出一个ClassNotFound的Exception</li>
<li>ClassLoader种类<br>3.1 BootStrapClassLoader:C++编写，用于加载核心库java.<em><br>3.2 ExtClassLoader:Java编写，用于加载扩展库javax.</em><br>3.3 AppClassLoader:Java编写，用于加载程序所在目录<br>3.4 自定义ClassLoader:Java编写，定制化加载</li>
<li>如果要自定义ClassLoader，就需要重写重写findClass找到文件，然后在defineClass中生成class对象</li>
<li>.java-&gt;.class-&gt;class对象</li>
</ol>
<p>##ClassLoader的双亲委派机制<br>先寻找类对象，按照customClassLoader-&gt;AppClassLoader-&gt;ExtClassLoader-&gt;BootsrapClassLoader的顺序查看是否已经加载该类（自底向上找class对象）<br>再找文件，按照BootstrapClassLoader-&gt;ExtClassLoader-&gt;AppClassLoader-&gt;CustomClassLoader<br>目的：防止多份同样字节码的加载</p>
<p>##类的加载方式</p>
<ol>
<li>隐式加载：new，程序在运行过程中使用new隐式调用对应的类加载器</li>
<li>显式加载，通过loadClass、forName显式加载类，获得类对象，再用newInstance获得实例</li>
<li>forName得到的类对象是完成了初始化的，loadClass得到的类是完成了链接的</li>
<li>forName的初始化特性可以帮助我们加载一些具有静态代码块的Driver；loadClass可以加速类的加载，初始化用到再说</li>
<li>类的装载过程：加载（ClassLoader加载字节码）、链接（校验、类变量分配空间、符号引用转换为直接引用）、初始化（类变量赋值、静态代码块）</li>
</ol>
<p>#JVM内存模型（JDK8后）</p>
<ol>
<li>计算机所有程序都是在内存中运行的</li>
<li>32位处理器可寻址空间，2^32；64位处理器可寻址空间，2^64</li>
<li><p>内存需要将物理地址映射为逻辑地址；内存寻址空间的划分：内核空间、用户空间。JVM运行在用户空间。</p>
</li>
<li><p>线程私有：程序计数器、虚拟机栈、本地方法栈</p>
</li>
<li>所有线程共享：MeataSpace、堆（包含字符串常量池，String str = “123”;）</li>
</ol>
<p>##1.程序计数器</p>
<ol>
<li>JVM的多线程是通过线程轮流切换，分配处理器的方式进行的，所以程序计数器和线程是一对一的关系</li>
<li>程序计数器是当前线程所执行的字节码指令的行号指示器</li>
<li>改变计数器的值来选取下一条需要执行的字节码指令</li>
<li>说白了，程序计数器告诉对应的线程要去执行哪一条字节码指令</li>
<li>只对线程执行的java方法计数，不对Native方法计数</li>
<li>不会发生内存泄漏的问题</li>
<li>程序计数器是逻辑计数器，帮助线程执行完成后能够恢复到正确的位置</li>
</ol>
<p>##2.Java虚拟机栈<br>包含单个线程每个方法执行的栈帧，栈帧中包含了局部变量表、操作数栈、动态连接、返回地址</p>
<ol>
<li>局部变量表：包含方法执行过程中的所有变量（this引用、所有方法参数、局部变量）</li>
<li>操作数栈：在执行字节码指令过程中会用到，展现赋值、计算过程中的操作数的出入栈过程</li>
<li>istore弹出操作数栈，iload压入操作数栈</li>
<li>虚拟机栈是JVM自动管理的，有固定容量的，里面存储栈帧</li>
<li>调用方法时栈帧自动压栈，调用结束，栈帧自动释放出栈，所以栈中内存不需要GC去回收，而会自动释放。</li>
</ol>
<p>##Java为什么会产生stackoverflow的异常？<br>线程调用方法时，会向虚拟机栈中压入栈帧，方法执行完毕，再将栈帧弹出<br>虚拟机栈的深度是固定的，当递归层数过多，栈桢数超过虚拟机栈深度，就会发生stackoverflowError<br>ps:解决方式：减少递归层数；使用循环替代递归</p>
<p>##虚拟机栈过多引发OutOfMemoryError<br>虚拟机栈的动态扩展时，无法申请到足够多的内存<br>e.g.无限创造线程</p>
<p>##3.本地方法栈<br>作用与虚拟机栈类似，主要作用于Native方法 e.g. forName0(C++编写)</p>
<p>##4.MetaSpace(线程共享部分)<br>存放Java类的元数据，包括class对象的field和method<br>元空间使用本地内存，而非jvm内存<br>替代了原本的方法区，静态变量所在的地方</p>
<p>##5. Java堆（线程共享部分）</p>
<ol>
<li>存放对象实例，为对象实例分配内存，当内存不足时，会抛出outOfMemory的异常</li>
<li>GC的主要管理区域</li>
<li>还包含常量池，内含字面量和符号引用量</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/19/java-foundamental/" data-id="ckbxbfwmw000l6cwzznevs8f0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-动态规划" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/18/动态规划/" class="article-date">
  <time datetime="2020-06-18T15:09:02.000Z" itemprop="datePublished">2020-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/18/动态规划/">动态规划</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#爬楼梯</p>
<ol>
<li>动态规划实质上就是一个递推的过程</li>
<li>先研究基本情况，再找出基本情况和之后情况的递推关系</li>
<li>本题中的地推情况就是dp[i]=dp[i-1]+dp[i-2]</li>
<li>创建dp数组时，应该是n+1的长度，然后从1开始</li>
</ol>
<p>#打家劫舍</p>
<ol>
<li>设置边界值</li>
<li>设置dp数组，初始条件</li>
<li>for循环+状态方程 max的关系</li>
<li>return dp[n]<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int rob(int[] nums) &#123;</span><br><span class="line">       <span class="keyword">if</span>(nums.length == 0)&#123;</span><br><span class="line">           <span class="built_in">return</span> 0;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(nums.length == 1)&#123;</span><br><span class="line">           <span class="built_in">return</span> nums[0];</span><br><span class="line">       &#125;</span><br><span class="line">       int[] dp = new int[nums.length];</span><br><span class="line">       dp[0] = nums[0];</span><br><span class="line">       dp[1] = Math.max(dp[0],nums[1]);</span><br><span class="line">       <span class="keyword">for</span>(int i=2;i&lt;nums.length;i++)&#123;</span><br><span class="line">           dp[i] = Math.max(nums[i]+dp[i-2],dp[i-1]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">return</span> dp[nums.length-1];        </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>##最大子段和</p>
<ol>
<li>需要注意的地方：因为要求是连续，所以当前的元素必须要选，之后只能做放弃前面or追加这两种选择</li>
<li>最终结果并不一定是最优解，结果会出现在中间，所以用一个max变量去打擂台<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == 0)&#123;</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == 1)&#123;</span><br><span class="line">            <span class="built_in">return</span> nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        int max_res = dp[0];</span><br><span class="line">        <span class="keyword">for</span>(int i=1;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i-1]&gt;0)&#123;</span><br><span class="line">                dp[i] = dp[i-1]+nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max_res &lt; dp[i])&#123;</span><br><span class="line">                max_res = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> max_res;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>##最长回文数</p>
<ol>
<li>特殊情况：空字符串、null指针</li>
<li>边界条件：单字符、双字符情况，3字符以上可以进入循环使用状态方程</li>
<li>状态方程：dp[i][j] = j-i&lt;2&amp;&amp;s[i]==s[j] 或者 dp[i][j] = dp[i+1][j-1]&amp;&amp;s[i]==s[j]</li>
<li>从最后一个不断向前，每次内循环向后扫描</li>
<li>使用HashMap记录下长度和值的对应关系，最后用最大的长度去取值并返回</li>
<li>i、j是两个字符串指针，i左j右<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">       <span class="keyword">if</span>(s == null || s.equals(<span class="string">""</span>))&#123;</span><br><span class="line">           <span class="built_in">return</span> s;</span><br><span class="line">       &#125;</span><br><span class="line">       boolean[][] dp = new boolean[s.length()][s.length()];</span><br><span class="line">       int max = 0;</span><br><span class="line">       HashMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(int i = s.length()-1;i&gt;=0;i--)&#123;</span><br><span class="line">           <span class="keyword">for</span>(int j=i;j&lt;s.length();j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                   <span class="keyword">if</span>(j-i&lt;2)&#123;</span><br><span class="line">                       dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span>(dp[i+1][j-1])&#123;</span><br><span class="line">                       dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(dp[i][j]&amp;&amp;max&lt;j-i+1)&#123;</span><br><span class="line">                   max = j-i+1;</span><br><span class="line">                   map.put(max,s.substring(i,j+1));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">return</span> map.get(max);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/18/动态规划/" data-id="ckbxbfwn5000r6cwzera6cpew" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/27/每日一题/">每日一题</a>
          </li>
        
          <li>
            <a href="/2020/06/26/Android开发屏幕显示/">Android开发屏幕显示</a>
          </li>
        
          <li>
            <a href="/2020/06/26/树/">树</a>
          </li>
        
          <li>
            <a href="/2020/06/25/abstract-class-and-interface/">abstract class and interface</a>
          </li>
        
          <li>
            <a href="/2020/06/25/singleton/">singleton</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>